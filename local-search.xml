<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NSThread</title>
    <link href="/2022/05/29/NSThread/"/>
    <url>/2022/05/29/NSThread/</url>
    
    <content type="html"><![CDATA[<h1 id="1-NSThread"><a href="#1-NSThread" class="headerlink" title="1 NSThread"></a>1 NSThread</h1><blockquote><p>本文的Demo链接：</p></blockquote><h2 id="1-1-创建并启动线程"><a href="#1-1-创建并启动线程" class="headerlink" title="1.1 创建并启动线程"></a>1.1 创建并启动线程</h2><ol><li><p>先创建线程，再启动线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)test1&#123;<br>    <span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(run) object:<span class="hljs-literal">nil</span>];<br>    [thread start];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)run&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;current thread----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建线程后自动启动线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)test2&#123;<br>    [<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(run) toTarget:<span class="hljs-keyword">self</span> withObject:<span class="hljs-literal">nil</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)run&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;current thread----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>隐式创建并启动</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)test3&#123;<br>    [<span class="hljs-built_in">NSThread</span> performSelectorInBackground:<span class="hljs-keyword">@selector</span>(run) withObject:<span class="hljs-literal">nil</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)run&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;current thread----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-2-其他API"><a href="#1-2-其他API" class="headerlink" title="1.2 其他API"></a>1.2 其他API</h2><ul><li><p>方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//线程睡眠</span><br>+ (<span class="hljs-type">void</span>)sleepForTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti;<br><span class="hljs-comment">//获取线程的优先级</span><br>+ (<span class="hljs-type">double</span>)threadPriority;<br><span class="hljs-comment">//设置线程优先级</span><br>+ (<span class="hljs-type">BOOL</span>)setThreadPriority:(<span class="hljs-type">double</span>)p;<br><br></code></pre></td></tr></table></figure></li><li><p>属性</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>) <span class="hljs-type">BOOL</span> isMainThread;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">class</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-type">BOOL</span> isMainThread;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">class</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSThread</span> *currentThread;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="1-3-线程控制方法"><a href="#1-3-线程控制方法" class="headerlink" title="1.3 线程控制方法"></a>1.3 线程控制方法</h2><ul><li>启动线程<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (<span class="hljs-type">void</span>)<span class="hljs-keyword">start</span>;<br></code></pre></td></tr></table></figure></li><li>阻塞线程<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-type">void</span>)sleepUntilDate:(<span class="hljs-built_in">NSDate</span> *)date;<br>+ (<span class="hljs-type">void</span>)sleepForTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti;<br></code></pre></td></tr></table></figure></li><li>停止线程<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">+ (void)<span class="hljs-keyword">exit</span>;<br></code></pre></td></tr></table></figure></li></ul><h1 id="2-线程通信"><a href="#2-线程通信" class="headerlink" title="2 线程通信"></a>2 线程通信</h1><p>在iOS开发中，经常会在其他线程进行耗时操作，执行完之后再回到主线程去更新UI。这就涉及到子线程和主线程之间的通信了.</p><blockquote><p>这一块在GCD中也有涉及，可以<a href="https://goggles-blog.vercel.app/2022/05/25/Grand-Central-Dispatch/#5-GCD%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1">参考</a></p></blockquote><p>先了解下官方提供的NSThread中用于线程通信的方法。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs erlang">// 在主线程上执行操作<br>- <span class="hljs-params">(void)</span>performSelectorOnMainThread:<span class="hljs-params">(SEL)</span>aSelector withObject:<span class="hljs-params">(id)</span>arg waitUntilDone:<span class="hljs-params">(BOOL)</span>wait;<br>- <span class="hljs-params">(void)</span>performSelectorOnMainThread:<span class="hljs-params">(SEL)</span>aSelector withObject:<span class="hljs-params">(id)</span>arg waitUntilDone:<span class="hljs-params">(BOOL)</span>wait modes:<span class="hljs-params">(NSArray&lt;NSString *&gt; *)</span>array;<br>  // equivalent to the first method with kCFRunLoopCommonModes<br><br>// 在指定线程上执行操作<br>- <span class="hljs-params">(void)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector onThread:<span class="hljs-params">(NSThread *)</span>thr withObject:<span class="hljs-params">(id)</span>arg waitUntilDone:<span class="hljs-params">(BOOL)</span>wait modes:<span class="hljs-params">(NSArray *)</span>array NS_AVAILABLE<span class="hljs-params">(<span class="hljs-number">10_5</span>, <span class="hljs-number">2_0</span>)</span>;<br>- <span class="hljs-params">(void)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector onThread:<span class="hljs-params">(NSThread *)</span>thr withObject:<span class="hljs-params">(id)</span>arg waitUntilDone:<span class="hljs-params">(BOOL)</span>wait NS_AVAILABLE<span class="hljs-params">(<span class="hljs-number">10_5</span>, <span class="hljs-number">2_0</span>)</span>;<br><br>// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法<br>- <span class="hljs-params">(id)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector;<br>- <span class="hljs-params">(id)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector withObject:<span class="hljs-params">(id)</span>object;<br>- <span class="hljs-params">(id)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector withObject:<span class="hljs-params">(id)</span>object1 withObject:<span class="hljs-params">(id)</span>object2;<br><br></code></pre></td></tr></table></figure><p>下面通过下载网络图片的demo来演示线程之间的通信</p><ol><li>开一个线程，在线程中执行下载图片的逻辑</li><li>返回主线程更新ui，将图片展示到UIImageView中</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)downloadImgOnThread&#123;<br>    [<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(downloadImg) toTarget:<span class="hljs-keyword">self</span> withObject:<span class="hljs-literal">nil</span>];<br>&#125;<br><br><br>- (<span class="hljs-type">void</span>)downloadImg&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;begin download----thread:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <br>    <span class="hljs-built_in">NSURL</span> *imgUrl = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;https://pic.leetcode-cn.com/1646910868-wkWFEj-%E6%A6%82%E7%8E%87%E9%A2%98%E9%9D%A2%E8%AF%95%E7%AA%81%E5%87%BB.png?x-oss-process=image%2Fformat%2Cwebp&quot;</span>];<br>    <br>    <span class="hljs-built_in">NSData</span> *imageData = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:imgUrl];<br>    <br>    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:imageData];<br>    <br>    [<span class="hljs-keyword">self</span> performSelectorOnMainThread:<span class="hljs-keyword">@selector</span>(refreshUI:) withObject:image waitUntilDone:<span class="hljs-literal">YES</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)refreshUI:(<span class="hljs-built_in">UIImage</span> *)image&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;update ui --- thread:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <br>    <span class="hljs-keyword">self</span>.imageView.image = image;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">57</span>:<span class="hljs-number">26</span>.<span class="hljs-number">545724</span>+<span class="hljs-number">0800</span> DemoForNSThread[<span class="hljs-number">77630</span>:<span class="hljs-number">1441161</span>] begin download----thread:&lt;NSThread: <span class="hljs-number">0</span>x600000d20280&gt;&#123;number = <span class="hljs-number">6</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">57</span>:<span class="hljs-number">26</span>.<span class="hljs-number">707026</span>+<span class="hljs-number">0800</span> DemoForNSThread[<span class="hljs-number">77630</span>:<span class="hljs-number">1441123</span>]<span class="hljs-meta"> [boringssl] boringssl_metrics_log_metric_block_invoke(153) Failed to log metrics</span><br><span class="hljs-meta">2022-05-29 16:57:26.809738+0800 DemoForNSThread[77630:1440965] update ui --- thread:&lt;_NSMainThread: 0x600000d74880&gt;&#123;number = 1, name = main&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/../img/NSThread/1.png" alt="更新后的界面"></p><h1 id="3-NSThread线程安全和线程同步"><a href="#3-NSThread线程安全和线程同步" class="headerlink" title="3 NSThread线程安全和线程同步"></a>3 NSThread线程安全和线程同步</h1><blockquote><p>这一块在GCD也有提到，可以<a href="https://goggles-blog.vercel.app/2022/05/25/Grand-Central-Dispatch/#6-7-1-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">参考</a></p></blockquote><p>这一块以卖票为例子，实现NSThread线程安全和线程同步问题。<br>需求：有100张演出票，两个窗口，分别售卖万能青年旅店、新裤子的票。</p><h2 id="3-1-非线程安全"><a href="#3-1-非线程安全" class="headerlink" title="3.1 非线程安全"></a>3.1 非线程安全</h2><p>先看非线程安全的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (void)noSafeClick&#123;<br>    [<span class="hljs-keyword">self</span> initTickerStatusNotSafe];<br>&#125;<br><br><span class="hljs-operator">-</span> (void)initTickerStatusNotSafe&#123;<br>    <span class="hljs-keyword">self</span>.ticketCount <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-keyword">self</span>.ticketSaleWinodw1 <span class="hljs-operator">=</span> [[<span class="hljs-type">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-meta">@selector</span>(saleTicketNotSafe) object:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">self</span>.ticketSaleWinodw1.name <span class="hljs-operator">=</span> @<span class="hljs-string">&quot;万能青年旅店&quot;</span>;<br>    <br>    <span class="hljs-keyword">self</span>.ticketSaleWinodw2 <span class="hljs-operator">=</span> [[<span class="hljs-type">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-meta">@selector</span>(saleTicketNotSafe) object:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">self</span>.ticketSaleWinodw2.name <span class="hljs-operator">=</span> @<span class="hljs-string">&quot;新裤子&quot;</span>;<br>    <br>    [<span class="hljs-keyword">self</span>.ticketSaleWinodw1 start];<br>    [<span class="hljs-keyword">self</span>.ticketSaleWinodw2 start];<br>&#125;<br><br><span class="hljs-operator">-</span> (void)saleTicketNotSafe&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.ticketCount <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">self</span>.ticketCount <span class="hljs-operator">--</span>;<br>            <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>,[<span class="hljs-type">NSString</span> stringWithFormat:@<span class="hljs-string">&quot;剩余票数：%1lu 窗口：%@&quot;</span>,(unsigned long)<span class="hljs-keyword">self</span>.ticketCount,[<span class="hljs-type">NSThread</span> currentThread].name]);<br>            [<span class="hljs-type">NSThread</span> sleepForTimeInterval:<span class="hljs-number">0.2</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;sold out&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查看输出结果：<br><img src="/../img/NSThread/2.png"><br>可以发现出现数据竞争的概率非常大，这在现实的开发中是不允许的。</p><h2 id="3-2-线程安全"><a href="#3-2-线程安全" class="headerlink" title="3.2 线程安全"></a>3.2 线程安全</h2><p>线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set&#x2F;ge等等各种方式。为了简单起见，这里不对各种锁的解决方案和性能做分析，只用最简单的@synchronized来保证线程安全，从而解决线程同步问题。</p><p>代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (void)safeClick&#123;<br>    [<span class="hljs-keyword">self</span> initTicketStatusSafe];<br>&#125;<br><br><span class="hljs-operator">-</span> (void)initTicketStatusSafe&#123;<br>    <span class="hljs-keyword">self</span>.ticketCount <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-keyword">self</span>.ticketSaleWinodw1 <span class="hljs-operator">=</span> [[<span class="hljs-type">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-meta">@selector</span>(saleTicketSafe) object:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">self</span>.ticketSaleWinodw1.name <span class="hljs-operator">=</span> @<span class="hljs-string">&quot;万能青年旅店&quot;</span>;<br>    <br>    <span class="hljs-keyword">self</span>.ticketSaleWinodw2 <span class="hljs-operator">=</span> [[<span class="hljs-type">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-meta">@selector</span>(saleTicketSafe) object:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">self</span>.ticketSaleWinodw2.name <span class="hljs-operator">=</span> @<span class="hljs-string">&quot;新裤子&quot;</span>;<br>    <br>    [<span class="hljs-keyword">self</span>.ticketSaleWinodw1 start];<br>    [<span class="hljs-keyword">self</span>.ticketSaleWinodw2 start];<br>&#125;<br><br><span class="hljs-operator">-</span> (void)saleTicketSafe&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-meta">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.ticketCount <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">self</span>.ticketCount <span class="hljs-operator">--</span>;<br>                <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>,[<span class="hljs-type">NSString</span> stringWithFormat:@<span class="hljs-string">&quot;卖出：%@ 一张，剩余票：%d &quot;</span>,[<span class="hljs-type">NSThread</span> currentThread].name,<span class="hljs-keyword">self</span>.ticketCount]);<br>                [<span class="hljs-type">NSThread</span> sleepForTimeInterval:<span class="hljs-number">0.2</span>];<br>            <br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;sold out&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：<br><img src="/../img/NSThread/3.png"></p><p><em>参考：</em></p><ul><li><a href="https://juejin.cn/post/6844903556009443335">iOS多线程：『pthread、NSThread』详尽总结</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS 多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grand Central Dispatch</title>
    <link href="/2022/05/25/Grand-Central-Dispatch/"/>
    <url>/2022/05/25/Grand-Central-Dispatch/</url>
    
    <content type="html"><![CDATA[<h1 id="1-多线程编程"><a href="#1-多线程编程" class="headerlink" title="1 多线程编程"></a>1 多线程编程</h1><p>线程是什么？在我们之前写的代码中，代码是从上到下顺序执行。这些源代码经过编译器转换后变成cpu的命令列。这些指令cpu依次执行，尽管会出现很多跳转指令，但也是一个没有分叉的路线。</p><p>现在的计算机使用多个cpu核，尽管如此1个cpu核仍然执行一条无分叉的路线。OS X和iOS的核心XNU内核在发送操作系统事件是会切换执行路径，进行上下文切换。由于使用多线程的程序需要在多个线程之前反复的进行上下文切换，因此看起来好像一个cpu并行执行多个线程。如果是多核cpu那就不是看起来。这就是多线程编程</p><blockquote><p>补充知识：<br>CPU物理核的数量&#x3D;cpu数量*每个cpu的核心数<br>虚拟核：通过超线程技术，可以将一个物理核虚拟成两个虚拟核，如4核8线程<br>单核cpu和多核cpu：都只有一个cpu，只是cpu上的核心数不同。多核cpu是多个单核cpu的代替方案，减少了体积和功耗。<br>一个核心同时只能执行一个线程<br>但是多线程编程会引起许多问题，比如多个线程更新相同的资源会导致数据不一致即数据竞争、多个线程互相等待资源即死锁、使用太多线程会导致消耗大量内存等。因此在使用多线程编程的时候需要注意这些问题。</p></blockquote><p>在iOS中，应用程序启动时最先执行的线程是主线程（UI线程），主线程用来绘制用户界面、处理触摸事件等。主线程中有一个runloop的主循环，如果在主线程执行长时间的操作会使得主循环阻塞，从而使得不能更新ui界面等问题，所以要使用多线程编程来避免这些问题。<br><img src="/../img/GCD/1.png"></p><h1 id="2-GCD概述"><a href="#2-GCD概述" class="headerlink" title="2 GCD概述"></a>2 GCD概述</h1><h2 id="2-1-什么是GCD"><a href="#2-1-什么是GCD" class="headerlink" title="2.1 什么是GCD"></a>2.1 什么是GCD</h2><blockquote><p>苹果官方对GCD的描述：Grand Central Dispatch (GCD)是异步执行任务的技术之一。一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p></blockquote><p>下面这段代码介绍了GCD如何使用</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">dispatch_async(queue,^&#123;<br>    <span class="hljs-regexp">//</span>耗时操作<br>    <span class="hljs-regexp">//</span>如数据库访问、网络请求等<br><br>    <span class="hljs-regexp">//</span>长时间处理完成后，主线程使用该处理后的结构<br>    dispatch_async(dispatch_get_main_queue(),^&#123;<br>        <span class="hljs-regexp">//</span>只能在ui线程执行的操作<br>        <span class="hljs-regexp">//</span>如ui更新等<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>dispatch_async(queue,^&#123;</code> 这行代码表示让处理在后台线程执行<br><code>dispatch_async(dispatch_get_main_queue(),^&#123;</code> 这行代码表示让处理在主线程执行。</p><p>GCD的优点：</p><ul><li>GCD可用于多核的并行运算</li><li>GCD会自动利用更多的CPU内核（双核 四核）</li><li>GCD会自动管理线程的生命周期，不需要程序员来管理线程</li></ul><h2 id="2-2-GCD任务和队列"><a href="#2-2-GCD任务和队列" class="headerlink" title="2.2 GCD任务和队列"></a>2.2 GCD任务和队列</h2><p>在学习GCD之前需要了解的两个概念：<strong>任务</strong> <strong>队列</strong></p><ul><li>任务：就是需要执行的操作，在GCD中就是放在Block中的代码。执行任务有两种类型：同步执行和异步执行。两者的区别在于：是否等待队列的任务执行结束，以及是否具有开启新线程的能力<ul><li>同步执行sync：同步添加任务到指定的queue中，在任务执行结束之前，会一直等待，直到队列里的任务完成之后才会继续执行。只能在当前线程执行任务，不具备开启新线程的能力。</li><li>异步执行async：异步添加任务到指定的queue中，不需要等待就可以继续执行任务。可以在新线程中执行任务，具有开启新线程的能力</li><li><em>NOTE：async具有开启新线程的能力，但不一定会开启新线程，这与指定队列类型有关</em></li></ul></li><li>队列Dispatch Queue：队列指的是用来存放任务的队列。采取FIFO的原则</li></ul><p>在GCD中队列分为两种，串行队列和并发队列</p><ul><li>串行队列：等待现在执行处理结束的<code>serial dispatch queue</code></li><li>不等待现在执行处理结束的<code>concurrent dispatch queue</code><br><em>NOTE：并发队列只有在异步的条件下才有效</em></li></ul><h1 id="3-GCD的使用"><a href="#3-GCD的使用" class="headerlink" title="3 GCD的使用"></a>3 GCD的使用</h1><h2 id="3-1-GCD的使用步骤"><a href="#3-1-GCD的使用步骤" class="headerlink" title="3.1 GCD的使用步骤"></a>3.1 GCD的使用步骤</h2><ol><li>创建队列（串行队列或者并发队列）</li><li>将任务追加到队列中，系统会根据任务类型执行任务</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> mytest = dispatch_queue_create(<span class="hljs-string">&quot;mytestqueue&quot;</span>, <span class="hljs-literal">nil</span>);<br><span class="hljs-built_in">dispatch_async</span>(mytest, ^&#123;<br>        <span class="hljs-comment">//todo</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;block &quot;</span>);<br>    &#125;);<br></code></pre></td></tr></table></figure><h2 id="3-2-队列的创建-x2F-获取"><a href="#3-2-队列的创建-x2F-获取" class="headerlink" title="3.2 队列的创建&#x2F;获取"></a>3.2 队列的创建&#x2F;获取</h2><p><em>创建队列</em><br>使用<code>dispatch_queue_create</code>方法来创建队列，需要传入两个参数：</p><ol><li>第一个参数表示队列的唯一标识符，用于debug，可为空（不建议为空）</li><li>第二个参数时用来识别是串行队列<code>DISPATCH_QUEUE_SERIAL</code>还是并发队列<code>DISPATCH_QUEUE_CONCURRENT</code>、</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dispatch_queue_t mytest</span> = dispatch_queue_create(<span class="hljs-string">&quot;mytestqueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br></code></pre></td></tr></table></figure><p>注意注意的是在创建serial dispatch queue时，每个queue同时只能执行一个处理，但是可以通过<code>dispatch_queue_create</code>创建多个queue。每个queue就会开启一个线程，这就引起上文说到的问题，开太多线程会导致内存被大量消耗，从而影响性能。</p><p>当多个线程更新相同资源会导致数据竞争时使用serial dispatch queue可以避免。</p><p><em>获取队列</em></p><ul><li>对于串行队列，GCD默认使用主队列mian dispatch queue来执行任务，可以使用<code>dispatch_get_main_queue</code>来获取主队列。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">dispatch_queue_t queue <span class="hljs-operator">=</span> dispatch_get_main_queue()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>对于并发队列，GCD默认使用全局并发队列global dispatch queue，可以使用<code>dispatch_get_global_queue</code>来获取全局并发队列，需要传入两个参数：</li></ul><ol><li>第一个参数表示队列属性，可以选择队列优先级或者Qos，一般使用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></li><li>第二个参数暂时不用，填0即可<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT，0);<br><br>/*<br>//队列Qos：<br><span class="hljs-deletion">- QOS_CLASS_USER_INTERACTIVE</span><br><span class="hljs-deletion">- QOS_CLASS_USER_INITIATED</span><br><span class="hljs-deletion">- QOS_CLASS_DEFAULT</span><br><span class="hljs-deletion">- QOS_CLASS_UTILITY</span><br><span class="hljs-deletion">- QOS_CLASS_BACKGROUND</span><br>//队列优先级（对应的Qos）：<br><span class="hljs-deletion">- DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span><br><span class="hljs-deletion">- DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span><br><span class="hljs-deletion">- DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span><br><span class="hljs-deletion">- DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span><br>*/<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-3-任务的创建"><a href="#3-3-任务的创建" class="headerlink" title="3.3 任务的创建"></a>3.3 任务的创建</h2><p>GCD提供了创建同步任务和异步任务的函数：</p><ul><li>同步执行任务：<br><code>dispatch_sync</code></li><li>异步执行任务：<br> <code>dispatch_async</code></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">dispatch_sync</span>(queue,^&#123;<br>    <span class="hljs-comment">//同步执行方法</span><br>&#125;);<br><br><span class="hljs-built_in">dispatch_async</span>(queue,^&#123;<br>    <span class="hljs-comment">//异步执行方法</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="3-4-任务和队列的不同组合"><a href="#3-4-任务和队列的不同组合" class="headerlink" title="3.4 任务和队列的不同组合"></a>3.4 任务和队列的不同组合</h2><table><thead><tr><th>任务</th><th>并发队列</th><th>串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步sync</td><td>只开了主线程，依然是串行执行任务</td><td>只开了主线程，依然是串行执行任务</td><td>死锁 卡住</td></tr><tr><td>异步async</td><td>开启新的线程，并发执行任务</td><td>开启了一个新的线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td></tr></tbody></table><blockquote><p>注意：从上边可看出： 『主线程』 中调用 『主队列』+『同步执行』 会导致死锁问题。这是因为 主队列中追加的同步任务 和 主线程本身的任务 两者之间相互等待，阻塞了 『主队列』，最终造成了主队列所在的线程（主线程）死锁问题。而如果我们在 『其他线程』 调用 『主队列』+『同步执行』，则不会阻塞 『主队列』，自然也不会造成死锁问题。最终的结果是：不会开启新线程，串行执行任务。</p></blockquote><h1 id="4-GCD的组合使用"><a href="#4-GCD的组合使用" class="headerlink" title="4 GCD的组合使用"></a>4 GCD的组合使用</h1><h2 id="4-1-同步执行-并发队列"><a href="#4-1-同步执行-并发队列" class="headerlink" title="4.1 同步执行+并发队列"></a>4.1 同步执行+并发队列</h2><p>在这种情况下，不会开启新的线程，顺序执行任务</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// 同步执行并发队列</span><br>- (<span class="hljs-type">void</span>)syncConcurrent&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;syncConcurrent--begin&quot;</span>);<br>    <br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;testQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;syncConcurrent---end&quot;</span>);<br>       <br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">49</span>.<span class="hljs-number">826628</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">99522</span>:<span class="hljs-number">735441</span>] currentThread----&lt;_NSMainThread: <span class="hljs-number">0</span>x6000005f0800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">49</span>.<span class="hljs-number">826680</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">99522</span>:<span class="hljs-number">735441</span>] syncConcurrent--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">51</span>.<span class="hljs-number">827838</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">99522</span>:<span class="hljs-number">735441</span>] <span class="hljs-number">1</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x6000005f0800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">53</span>.<span class="hljs-number">829130</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">99522</span>:<span class="hljs-number">735441</span>] <span class="hljs-number">2</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x6000005f0800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">55</span>.<span class="hljs-number">829934</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">99522</span>:<span class="hljs-number">735441</span>] <span class="hljs-number">3</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x6000005f0800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">26</span>:<span class="hljs-number">55</span>.<span class="hljs-number">830279</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">99522</span>:<span class="hljs-number">735441</span>] syncConcurrent---end<br><br></code></pre></td></tr></table></figure><p>从输出结果可以看出：</p><ol><li>同步执行+并发队列，所有的任务都在主线程执行，并没有开启新的线程，这是因为sync没有开启新线程的能力。</li><li>所有的任务都是按FIFO顺序执行，这是因为虽然并发队列可以并发执行任务，但是由于本身无法创建多个线程，因此不能并发，只能顺序执行。</li><li>所有任务都在打印的 syncConcurrent—begin 和 syncConcurrent—end 之间执行（同步任务 需要等待队列的任务执行结束）。</li></ol><h2 id="4-2-异步执行-并发队列"><a href="#4-2-异步执行-并发队列" class="headerlink" title="4.2 异步执行+并发队列"></a>4.2 异步执行+并发队列</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// 异步并发</span><br>- (<span class="hljs-type">void</span>)asyncConcurrent&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread===%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;asyncConcurrent--begin&quot;</span>);<br>    <br>    <span class="hljs-comment">//创建并发队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;testQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;asyncConcurrent---end&quot;</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">41</span>.<span class="hljs-number">608717</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">1422</span>:<span class="hljs-number">749657</span>] currentThread===&lt;_NSMainThread: <span class="hljs-number">0</span>x60000398c880&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">41</span>.<span class="hljs-number">608764</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">1422</span>:<span class="hljs-number">749657</span>] asyncConcurrent--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">41</span>.<span class="hljs-number">608803</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">1422</span>:<span class="hljs-number">749657</span>] asyncConcurrent---end<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">43</span>.<span class="hljs-number">611552</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">1422</span>:<span class="hljs-number">749843</span>] <span class="hljs-number">3</span>----&lt;NSThread: <span class="hljs-number">0</span>x6000039dc0c0&gt;&#123;number = <span class="hljs-number">7</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">43</span>.<span class="hljs-number">613877</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">1422</span>:<span class="hljs-number">749839</span>] <span class="hljs-number">1</span>----&lt;NSThread: <span class="hljs-number">0</span>x6000039c2d80&gt;&#123;number = <span class="hljs-number">6</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">40</span>:<span class="hljs-number">43</span>.<span class="hljs-number">613880</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">1422</span>:<span class="hljs-number">749844</span>] <span class="hljs-number">2</span>----&lt;NSThread: <span class="hljs-number">0</span>x600003993180&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br></code></pre></td></tr></table></figure><p>从输出结果中可以看出：</p><ol><li>除了当前的主线程之外，系统又开启了三个线程，这是因为异步执行具有开启新线程的能力。</li><li>任务是同时执行的，这是因为并发队列可以开启多个线程，同时执行多个任务</li><li>所有任务是在打印的 syncConcurrent—begin 和 syncConcurrent—end 之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行不做等待，可以继续执行任务）。</li></ol><h2 id="4-3-同步执行-串行队列"><a href="#4-3-同步执行-串行队列" class="headerlink" title="4.3 同步执行+串行队列"></a>4.3 同步执行+串行队列</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// 同步串行</span><br>- (<span class="hljs-type">void</span>)syncSerial&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread===%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;syncSerial--begin&quot;</span>);<br>    <br>    <span class="hljs-comment">//创建并发队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;testQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;syncSerial---end&quot;</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">02</span>.<span class="hljs-number">404274</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2384</span>:<span class="hljs-number">758988</span>] currentThread===&lt;_NSMainThread: <span class="hljs-number">0</span>x60000102c880&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">02</span>.<span class="hljs-number">404317</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2384</span>:<span class="hljs-number">758988</span>] syncSerial--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">04</span>.<span class="hljs-number">405534</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2384</span>:<span class="hljs-number">758988</span>] <span class="hljs-number">1</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x60000102c880&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">06</span>.<span class="hljs-number">407035</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2384</span>:<span class="hljs-number">758988</span>] <span class="hljs-number">2</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x60000102c880&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">08</span>.<span class="hljs-number">408848</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2384</span>:<span class="hljs-number">758988</span>] <span class="hljs-number">3</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x60000102c880&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">50</span>:<span class="hljs-number">08</span>.<span class="hljs-number">409269</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2384</span>:<span class="hljs-number">758988</span>] syncSerial---end<br></code></pre></td></tr></table></figure><p>从输出结果可以看出：</p><ol><li>所有的任务都在主线程执行，并没有开启新的线程，这是因为sync没有开启新线程的能力。</li><li>所有的任务都是按FIFO顺序执行，这是因为串行队列每次只能执行一个任务。</li><li>所有任务都在打印的 syncConcurrent—begin 和 syncConcurrent—end 之间执行（同步任务需要等待队列的任务执行结束）。</li></ol><h2 id="4-4-异步执行-串行队列"><a href="#4-4-异步执行-串行队列" class="headerlink" title="4.4 异步执行+串行队列"></a>4.4 异步执行+串行队列</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// 异步串行</span><br>- (<span class="hljs-type">void</span>)asyncSerial&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread===%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;asyncSerial--begin&quot;</span>);<br>    <br>    <span class="hljs-comment">//创建并发队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;testQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;asyncSerial---end&quot;</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">54</span>:<span class="hljs-number">38</span>.<span class="hljs-number">112599</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2889</span>:<span class="hljs-number">764125</span>] currentThread===&lt;_NSMainThread: <span class="hljs-number">0</span>x600000b6c540&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">54</span>:<span class="hljs-number">38</span>.<span class="hljs-number">112651</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2889</span>:<span class="hljs-number">764125</span>] asyncSerial--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">54</span>:<span class="hljs-number">38</span>.<span class="hljs-number">112698</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2889</span>:<span class="hljs-number">764125</span>] asyncSerial---end<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">54</span>:<span class="hljs-number">40</span>.<span class="hljs-number">117996</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2889</span>:<span class="hljs-number">764325</span>] <span class="hljs-number">1</span>----&lt;NSThread: <span class="hljs-number">0</span>x600000b79680&gt;&#123;number = <span class="hljs-number">7</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">54</span>:<span class="hljs-number">42</span>.<span class="hljs-number">119236</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2889</span>:<span class="hljs-number">764325</span>] <span class="hljs-number">2</span>----&lt;NSThread: <span class="hljs-number">0</span>x600000b79680&gt;&#123;number = <span class="hljs-number">7</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">10</span>:<span class="hljs-number">54</span>:<span class="hljs-number">44</span>.<span class="hljs-number">120922</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">2889</span>:<span class="hljs-number">764325</span>] <span class="hljs-number">3</span>----&lt;NSThread: <span class="hljs-number">0</span>x600000b79680&gt;&#123;number = <span class="hljs-number">7</span>, name = (null)&#125; <br></code></pre></td></tr></table></figure><p>从输出结果可以看出：</p><ol><li>开启了一个新的线程，这是因为async具有开启新线程的能力，但是穿行队列只能开启一个线程</li><li>所有任务是在打印的 syncConcurrent—begin 和 syncConcurrent—end 之后才开始执行的（异步执行 不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的</li></ol><h2 id="4-5-同步执行-主队列"><a href="#4-5-同步执行-主队列" class="headerlink" title="4.5 同步执行+主队列"></a>4.5 同步执行+主队列</h2><ul><li>主队列：GCD默认提供的是串行队列</li></ul><h3 id="4-5-1-主线程中执行-同步执行-主队列"><a href="#4-5-1-主线程中执行-同步执行-主队列" class="headerlink" title="4.5.1 主线程中执行[同步执行+主队列]"></a>4.5.1 主线程中执行[同步执行+主队列]</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// 同步主队列</span><br>- (<span class="hljs-type">void</span>)syncMain&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread===%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;syncMain--begin&quot;</span>);<br>    <br>    <span class="hljs-comment">//获取主队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;syncMain---end&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">01</span>:<span class="hljs-number">06</span>.<span class="hljs-number">744031</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">3593</span>:<span class="hljs-number">771124</span>] currentThread===&lt;_NSMainThread: <span class="hljs-number">0</span>x6000027bc7c0&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">01</span>:<span class="hljs-number">06</span>.<span class="hljs-number">744074</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">3593</span>:<span class="hljs-number">771124</span>] syncMain--begin<br></code></pre></td></tr></table></figure><p>从输出结果上可以看出有许多不同的地方：<br>追加到主队列的任务1、任务2、任务3都不能执行，并且syncMain—end也没有打印。这是因为主线在执行syncMain方法的时候会把任务添加到主线程的队列中，而同步执行会等待当前队列中的任务执行完毕才会继续执行。因此当任务1追加到主队列中，主队列又在等在syncMain执行；而syncMain需要执行完任务1才能继续执行，因此陷入了死锁。</p><h3 id="4-5-2-其他线程执行-同步执行-主队列"><a href="#4-5-2-其他线程执行-同步执行-主队列" class="headerlink" title="4.5.2 其他线程执行+[同步执行+主队列]"></a>4.5.2 其他线程执行+[同步执行+主队列]</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-built_in">NSThread</span> detachNewThreadSelector:<span class="hljs-keyword">@selector</span>(syncMain) toTarget:<span class="hljs-keyword">self</span> withObject:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">23</span>.<span class="hljs-number">863195</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">4526</span>:<span class="hljs-number">779754</span>] currentThread===&lt;NSThread: <span class="hljs-number">0</span>x60000131d400&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">23</span>.<span class="hljs-number">863245</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">4526</span>:<span class="hljs-number">779754</span>] syncMain--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">25</span>.<span class="hljs-number">872996</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">4526</span>:<span class="hljs-number">779552</span>] <span class="hljs-number">1</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x600001344800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">27</span>.<span class="hljs-number">877613</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">4526</span>:<span class="hljs-number">779552</span>] <span class="hljs-number">2</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x600001344800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">29</span>.<span class="hljs-number">879781</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">4526</span>:<span class="hljs-number">779552</span>] <span class="hljs-number">3</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x600001344800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">29</span>.<span class="hljs-number">880257</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">4526</span>:<span class="hljs-number">779754</span>] syncMain---end<br></code></pre></td></tr></table></figure><p>在其他线程执行[同步执行+主队列],从输出结果中可以看出：</p><ol><li>所有任务都在主线程执行，而不是在当前线程。</li><li>所有任务都在打印的 syncConcurrent—begin 和 syncConcurrent—end 之间执行（同步任务 需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（主队列是 串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li><li>之所以这种情况不会死锁是因为，syncMain在线程1，而任务1、2、3放在主线程中。syncMain将任务1追加到主队列中，主队列没有在执行的任务，任务1开始执行，执行完毕后依次执行任务2、3，当任务3执行完毕，syncMain也执行完了,因此不会死锁。</li></ol><h2 id="4-6-异步执行-主队列"><a href="#4-6-异步执行-主队列" class="headerlink" title="4.6 异步执行+主队列"></a>4.6 异步执行+主队列</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// 异步执行+主队列</span><br>- (<span class="hljs-type">void</span>)asyncMain&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread===%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;asyncMain--begin&quot;</span>);<br>    <br>    <span class="hljs-comment">//获取主队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//模拟耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;asyncMain---end&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">17</span>:<span class="hljs-number">28</span>.<span class="hljs-number">327650</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">5255</span>:<span class="hljs-number">786677</span>] currentThread===&lt;_NSMainThread: <span class="hljs-number">0</span>x600003f300c0&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">17</span>:<span class="hljs-number">28</span>.<span class="hljs-number">327697</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">5255</span>:<span class="hljs-number">786677</span>] asyncMain--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">17</span>:<span class="hljs-number">28</span>.<span class="hljs-number">327739</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">5255</span>:<span class="hljs-number">786677</span>] asyncMain---end<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">17</span>:<span class="hljs-number">30</span>.<span class="hljs-number">337717</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">5255</span>:<span class="hljs-number">786677</span>] <span class="hljs-number">1</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x600003f300c0&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">17</span>:<span class="hljs-number">32</span>.<span class="hljs-number">338226</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">5255</span>:<span class="hljs-number">786677</span>] <span class="hljs-number">2</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x600003f300c0&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">17</span>:<span class="hljs-number">34</span>.<span class="hljs-number">339835</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">5255</span>:<span class="hljs-number">786677</span>] <span class="hljs-number">3</span>----&lt;_NSMainThread: <span class="hljs-number">0</span>x600003f300c0&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br></code></pre></td></tr></table></figure><p>从输出结果可以看出：</p><ol><li>所有任务都在主线程执行，没有开启新的线程，虽然异步执行具有开启新线程的能力，但是主队列在主线程执行</li><li>所有任务都在打印的 syncConcurrent—begin 和 syncConcurrent—end 之后执行（异步任务不需要等待，可以继续执行任务）。</li><li>任务是按顺序执行的（主队列是 串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ol><h1 id="5-GCD线程间的通信"><a href="#5-GCD线程间的通信" class="headerlink" title="5 GCD线程间的通信"></a>5 GCD线程间的通信</h1><p>在iOS开发中，我们经常会将耗时操作放在其他线程中进行，当这些耗时操作完成了，该怎么通知主线程？这就需要学习线程间的通信。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)communication&#123;<br>    <span class="hljs-comment">//获取全局队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">//获取主队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();<br>    <br>    <span class="hljs-comment">//异步执行耗时操作</span><br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">//耗时操作</span><br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>        <br>        <span class="hljs-comment">//回到主线程</span><br>        <span class="hljs-built_in">dispatch_async</span>(mainQueue, ^&#123;<br>            [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2--%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>        &#125;);<br>    &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">53</span>:<span class="hljs-number">36</span>.<span class="hljs-number">003203</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">9678</span>:<span class="hljs-number">826205</span>] <span class="hljs-number">1</span>---&lt;NSThread: <span class="hljs-number">0</span>x600001f43180&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">11</span>:<span class="hljs-number">53</span>:<span class="hljs-number">38</span>.<span class="hljs-number">004165</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">9678</span>:<span class="hljs-number">826015</span>] <span class="hljs-number">2</span>--&lt;_NSMainThread: <span class="hljs-number">0</span>x600001f0c240&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br></code></pre></td></tr></table></figure><p>可以看到在其他线程执行完耗时操作之后，又回到主线程去执行其他操作。</p><h1 id="6-GCD的其他API"><a href="#6-GCD的其他API" class="headerlink" title="6 GCD的其他API"></a>6 GCD的其他API</h1><h2 id="6-1-变更优先级方法：dispatch-set-target-queue"><a href="#6-1-变更优先级方法：dispatch-set-target-queue" class="headerlink" title="6.1 变更优先级方法：dispatch_set_target_queue"></a>6.1 变更优先级方法：<code>dispatch_set_target_queue</code></h2><p>使用<code>dispatch_queue_create</code>函数生成的队列不管是串行的还是并发的，都是和global队列的优先级相同。如果想改变优先级，可以使用<code>dispatch_set_target_queue</code>方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//创建串行队列</span><br>dispatch_queue_t queue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-params">nil</span>)</span>;<br><br><span class="hljs-comment">//想改成后台优先级</span><br>dispatch_queue_t targetQueue = dispatch<span class="hljs-constructor">_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0)</span>;<br><br><span class="hljs-comment">//更改优先级</span><br>dispatch<span class="hljs-constructor">_set_target_queue(<span class="hljs-params">queue</span>, <span class="hljs-params">targetQueue</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="6-2-延迟执行方法：dispatch-after"><a href="#6-2-延迟执行方法：dispatch-after" class="headerlink" title="6.2 延迟执行方法：dispatch_after"></a>6.2 延迟执行方法：<code>dispatch_after</code></h2><p>我们经常会遇到这种情况：想在指定时间后执行任务，可以使用<code>dispatch_after</code>实现。<br>但是需要注意的是，<code>dispatch_after</code>并不在指定时间后执行处理，而是在指定时间后追加到dispatch queue中.<br>第一个参数是dispatch_time_t类型的值，可以使用dispatch_time函数或者dispatch_walltime函数来指定时间。<br>第二个参数执行要追加处理的dispatch queue<br>第三个参数是要执行的block</p><p>dispatch_time函数从第一个参数中指定的时间开始，到第二个参数指定的单位时间后时间。<br>dispatch_time是用来计算相对时间，dispatch_walltime用来计算绝对时间</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;currentThread===%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;after--begin&quot;</span>)</span>;<br><br>dispatch<span class="hljs-constructor">_after(<span class="hljs-params">dispatch_time</span>(DISPATCH_TIME_NOW, (<span class="hljs-params">int64_t</span>)</span>(<span class="hljs-number">2.0</span>*NSEC_PER_SEC)), dispatch<span class="hljs-constructor">_get_main_queue()</span>,^&#123;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;after--%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">01</span>.<span class="hljs-number">529384</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">17944</span>:<span class="hljs-number">913332</span>] currentThread===&lt;_NSMainThread: <span class="hljs-number">0</span>x600002d1c880&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">01</span>.<span class="hljs-number">529430</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">17944</span>:<span class="hljs-number">913332</span>] after--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">33</span>:<span class="hljs-number">03</span>.<span class="hljs-number">721971</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">17944</span>:<span class="hljs-number">913332</span>] after--&lt;_NSMainThread: <span class="hljs-number">0</span>x600002d1c880&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-只执行一次dispatch-once"><a href="#6-3-只执行一次dispatch-once" class="headerlink" title="6.3 只执行一次dispatch_once"></a>6.3 只执行一次<code>dispatch_once</code></h2><p><code>dispatch_once</code>函数保证在应用程序执行中之执行一次，在创建单例或者整个程序只执行一次的代码的时候就会用到<code>dispatch_once</code>方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// dispatch_once</span><br>- (<span class="hljs-type">void</span>)once&#123;<br>    <span class="hljs-comment">//之前的初始化</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">BOOL</span> flags = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">if</span>(flags == <span class="hljs-literal">NO</span>)&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;initialize1---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>        flags == <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//使用dispatch once</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> pred;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;pred, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;initialize2---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用异步执行+并发队列的输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">18</span>.<span class="hljs-number">576136</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931416</span>] currentThread===&lt;_NSMainThread: <span class="hljs-number">0</span>x6000011ac800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">18</span>.<span class="hljs-number">576180</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931416</span>] asyncConcurrent--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">18</span>.<span class="hljs-number">576216</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931416</span>] asyncConcurrent---end<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">20</span>.<span class="hljs-number">581414</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931613</span>] <span class="hljs-number">2</span>----&lt;NSThread: <span class="hljs-number">0</span>x6000011e0680&gt;&#123;number = <span class="hljs-number">8</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">20</span>.<span class="hljs-number">581413</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931616</span>] <span class="hljs-number">3</span>----&lt;NSThread: <span class="hljs-number">0</span>x6000011ed240&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">20</span>.<span class="hljs-number">581414</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931620</span>] <span class="hljs-number">1</span>----&lt;NSThread: <span class="hljs-number">0</span>x600001193f40&gt;&#123;number = <span class="hljs-number">6</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">20</span>.<span class="hljs-number">581868</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931613</span>] flags---&lt;NSThread: <span class="hljs-number">0</span>x6000011e0680&gt;&#123;number = <span class="hljs-number">8</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">20</span>.<span class="hljs-number">581892</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931620</span>] flags---&lt;NSThread: <span class="hljs-number">0</span>x600001193f40&gt;&#123;number = <span class="hljs-number">6</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">19</span>:<span class="hljs-number">50</span>:<span class="hljs-number">20</span>.<span class="hljs-number">582039</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">19718</span>:<span class="hljs-number">931613</span>] once---&lt;NSThread: <span class="hljs-number">0</span>x6000011e0680&gt;&#123;number = <span class="hljs-number">8</span>, name = (null)&#125;<br></code></pre></td></tr></table></figure><p>从结果上可以看出使用<code>dispatch_once</code>是线程安全的，而一般的初始化在多线程的情况下会出现多次初始化的情况。</p><h2 id="6-4-队列组dispatch-group"><a href="#6-4-队列组dispatch-group" class="headerlink" title="6.4 队列组dispatch_group"></a>6.4 队列组<code>dispatch_group</code></h2><p>有时候我们需要执行多个操作，在所有操作执行完毕之后再进行一个结束处理，如果只是用串行队列，那么只需要将任务追加到串行队列中，并在最后追加结束处理任务；如果使用到了并发队列，或者是多个队列的时候，我们就可以用到GCD的队列组。</p><p>调用队列组的<code>dispatch_group_async</code>函数将任务加到队列中，将队列加到队列组中。<br>在调用队列组的<code>dispatch_group_notify</code>函数回到指定线程执行任务。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lisp">dispatch_queue_t queue = dispatch_get_global_queue(<span class="hljs-name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br><br>dispatch_group_t group = dispatch_group_create()<span class="hljs-comment">;</span><br><br>dispatch_group_async(<span class="hljs-name">group</span>, queue, ^&#123;<br>    NSLog(@<span class="hljs-string">&quot;block1----%@&quot;</span>,[NSThread currentThread])<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br><br>dispatch_group_async(<span class="hljs-name">group</span>, queue, ^&#123;<br>    NSLog(@<span class="hljs-string">&quot;block2----%@&quot;</span>,[NSThread currentThread])<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br><br>dispatch_group_async(<span class="hljs-name">group</span>, queue, ^&#123;<br>    NSLog(@<span class="hljs-string">&quot;block3----%@&quot;</span>,[NSThread currentThread])<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br><br>dispatch_group_notify(<span class="hljs-name">group</span>, dispatch_get_main_queue(), ^&#123;<br>    NSLog(@<span class="hljs-string">&quot;done----%@&quot;</span>,[NSThread currentThread])<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">05</span>:<span class="hljs-number">09</span>.<span class="hljs-number">667799</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">26927</span>:<span class="hljs-number">993101</span>] block2----&lt;NSThread: <span class="hljs-number">0</span>x6000022905c0&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">05</span>:<span class="hljs-number">09</span>.<span class="hljs-number">667800</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">26927</span>:<span class="hljs-number">993095</span>] block1----&lt;NSThread: <span class="hljs-number">0</span>x6000022ddc40&gt;&#123;number = <span class="hljs-number">7</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">05</span>:<span class="hljs-number">09</span>.<span class="hljs-number">667800</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">26927</span>:<span class="hljs-number">993099</span>] block3----&lt;NSThread: <span class="hljs-number">0</span>x6000022dc3c0&gt;&#123;number = <span class="hljs-number">3</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">05</span>:<span class="hljs-number">09</span>.<span class="hljs-number">676738</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">26927</span>:<span class="hljs-number">992915</span>] done----&lt;_NSMainThread: <span class="hljs-number">0</span>x6000022847c0&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><br></code></pre></td></tr></table></figure><p>如果使用<code>dispatch_group_wait</code>函数，会阻塞当前线程，等待指定group中的任务执行完毕之后，才会继续往下执行。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br><br>dispatch_group_t group = dispatch_group_create();<br><br>dispatch_group_async(group, queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;block1----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br>dispatch_group_async(group, queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;block2----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br>dispatch_group_async(group, queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;block3----%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br>    <br>dispatch_group_wait(group,DISPATCH_TIME_FOREVER);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;111&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">08</span>:<span class="hljs-number">21</span>.<span class="hljs-number">002870</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">27255</span>:<span class="hljs-number">996748</span>] block1----&lt;NSThread: <span class="hljs-number">0</span>x600001510080&gt;&#123;number = <span class="hljs-number">7</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">08</span>:<span class="hljs-number">21</span>.<span class="hljs-number">002948</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">27255</span>:<span class="hljs-number">996752</span>] block2----&lt;NSThread: <span class="hljs-number">0</span>x6000015143c0&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">08</span>:<span class="hljs-number">21</span>.<span class="hljs-number">002989</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">27255</span>:<span class="hljs-number">996753</span>] block3----&lt;NSThread: <span class="hljs-number">0</span>x600001509080&gt;&#123;number = <span class="hljs-number">3</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">08</span>:<span class="hljs-number">21</span>.<span class="hljs-number">003341</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">27255</span>:<span class="hljs-number">996682</span>] <span class="hljs-number">111</span><br></code></pre></td></tr></table></figure><h2 id="6-5-GCD栅栏方法：dispatch-barrier-async"><a href="#6-5-GCD栅栏方法：dispatch-barrier-async" class="headerlink" title="6.5 GCD栅栏方法：dispatch_barrier_async"></a>6.5 GCD栅栏方法：<code>dispatch_barrier_async</code></h2><p>在访问数据库或者文件时候，使用串行队列可以避免数据竞争的问题。如果要使用异步执行两组操作，并且保证第一组操作执行完毕之后，第二组操作才能进行，这就需要使用<code>dispatch_barrier_async</code>栅栏将两组异步操作分隔开。</p><p>dispatch_barrier_async 方法会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 dispatch_barrier_async 方法追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：<br><img src="/../img/GCD/barrier.png"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"> <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;testQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br>dispatch_barrier_async(queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;barrier---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">21</span>:<span class="hljs-number">47</span>.<span class="hljs-number">945844</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">28637</span>:<span class="hljs-number">1011052</span>] <span class="hljs-number">2</span>---&lt;NSThread: <span class="hljs-number">0</span>x600002cda300&gt;&#123;number = <span class="hljs-number">4</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">21</span>:<span class="hljs-number">47</span>.<span class="hljs-number">945833</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">28637</span>:<span class="hljs-number">1011051</span>] <span class="hljs-number">1</span>---&lt;NSThread: <span class="hljs-number">0</span>x600002cda380&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">21</span>:<span class="hljs-number">49</span>.<span class="hljs-number">948949</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">28637</span>:<span class="hljs-number">1011051</span>] barrier---&lt;NSThread: <span class="hljs-number">0</span>x600002cda380&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">21</span>:<span class="hljs-number">51</span>.<span class="hljs-number">950627</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">28637</span>:<span class="hljs-number">1011051</span>] <span class="hljs-number">3</span>---&lt;NSThread: <span class="hljs-number">0</span>x600002cda380&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><br></code></pre></td></tr></table></figure><h2 id="6-6-快速迭代方法-dispatch-apply"><a href="#6-6-快速迭代方法-dispatch-apply" class="headerlink" title="6.6 快速迭代方法 dispatch_apply"></a>6.6 快速迭代方法 <code>dispatch_apply</code></h2><p><code>dispatch_apply</code>是<code>dispatch_sync</code>和dispatch group的关联api。该函数按指定的次数将指定的block添加到指定的group中，等全部任务执行结束。</p><p>并发队列进行异步执行，遍历0～5，apply函数可以使得多个线程异步遍历各个数字</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> dispatch_queue_t queue = dispatch<span class="hljs-constructor">_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>;<br>    <br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;apply--begin&quot;</span>)</span>;<br>dispatch<span class="hljs-constructor">_apply(6, <span class="hljs-params">queue</span>, ^(<span class="hljs-params">size_t</span> <span class="hljs-params">iteration</span>)</span> &#123;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;%zd --- %@&quot;</span>,<span class="hljs-params">iteration</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>&#125;);<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;apply--end&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">30</span>:<span class="hljs-number">59</span>.<span class="hljs-number">918563</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">29571</span>:<span class="hljs-number">1021102</span>] apply--begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">30</span>:<span class="hljs-number">59</span>.<span class="hljs-number">918643</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">29571</span>:<span class="hljs-number">1021102</span>] <span class="hljs-number">1</span> --- &lt;_NSMainThread: <span class="hljs-number">0</span>x6000036b8800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">30</span>:<span class="hljs-number">59</span>.<span class="hljs-number">918665</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">29571</span>:<span class="hljs-number">1021252</span>] <span class="hljs-number">2</span> --- &lt;NSThread: <span class="hljs-number">0</span>x6000036e8140&gt;&#123;number = <span class="hljs-number">3</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">30</span>:<span class="hljs-number">59</span>.<span class="hljs-number">918644</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">29571</span>:<span class="hljs-number">1021246</span>] <span class="hljs-number">0</span> --- &lt;NSThread: <span class="hljs-number">0</span>x6000036f0240&gt;&#123;number = <span class="hljs-number">6</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">30</span>:<span class="hljs-number">59</span>.<span class="hljs-number">918677</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">29571</span>:<span class="hljs-number">1021249</span>] <span class="hljs-number">3</span> --- &lt;NSThread: <span class="hljs-number">0</span>x6000036ea500&gt;&#123;number = <span class="hljs-number">7</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">30</span>:<span class="hljs-number">59</span>.<span class="hljs-number">918683</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">29571</span>:<span class="hljs-number">1021102</span>] <span class="hljs-number">4</span> --- &lt;_NSMainThread: <span class="hljs-number">0</span>x6000036b8800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">30</span>:<span class="hljs-number">59</span>.<span class="hljs-number">918694</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">29571</span>:<span class="hljs-number">1021251</span>] <span class="hljs-number">5</span> --- &lt;NSThread: <span class="hljs-number">0</span>x6000036e8780&gt;&#123;number = <span class="hljs-number">5</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">21</span>:<span class="hljs-number">30</span>:<span class="hljs-number">59</span>.<span class="hljs-number">918786</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">29571</span>:<span class="hljs-number">1021102</span>] apply--end<br><br></code></pre></td></tr></table></figure><p>因为是在并发队列中异步执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是 apply—end 一定在最后执行。这是因为 dispatch_apply 方法会等待全部任务执行完毕。</p><h2 id="6-7-信号量dispatch-semaphore"><a href="#6-7-信号量dispatch-semaphore" class="headerlink" title="6.7 信号量dispatch_semaphore"></a>6.7 信号量<code>dispatch_semaphore</code></h2><p>如前文所述，当并发执行数据更新操作时，容易出现数据竞争，虽然可以使用串行队列或者栅栏函数可以避免，但是可以进行更细粒度的排他控制–信号量。</p><p><code>dispatch semophore</code>时持有计数的信号，当计数小于等于0时需要等待，当计数大于0时，可以执行。</p><ul><li><code>dispatch_semaphore_create</code>：创建一个信号量并初始化信号总数</li><li><code>dispatch_semaphore_signal</code>：v操作，发送一个信号，让信号量+1</li><li><code>dispatch_semaphore_wait</code>：p操作，请求操作，使信号量-1，当信号量小于0时会阻塞当前线程。</li></ul><p>信号量在实际开发中主要用于</p><ul><li>保持线程同步，将异步执行转换成同步执行任务</li><li>保证线程安全，为线程枷锁</li></ul><h3 id="6-7-1-线程同步"><a href="#6-7-1-线程同步" class="headerlink" title="6.7.1 线程同步"></a>6.7.1 线程同步</h3><p>我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSArray</span> *)tasksForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath &#123;<br>    __block <span class="hljs-built_in">NSArray</span> *tasks = <span class="hljs-literal">nil</span>;<br>    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">0</span>);<br>    [<span class="hljs-keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="hljs-built_in">NSArray</span> *dataTasks, <span class="hljs-built_in">NSArray</span> *uploadTasks, <span class="hljs-built_in">NSArray</span> *downloadTasks) &#123;<br>        <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(dataTasks))]) &#123;<br>            tasks = dataTasks;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(uploadTasks))]) &#123;<br>            tasks = uploadTasks;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(downloadTasks))]) &#123;<br>            tasks = downloadTasks;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(tasks))]) &#123;<br>            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:<span class="hljs-string">@&quot;@unionOfArrays.self&quot;</span>];<br>        &#125;<br><br>        dispatch_semaphore_signal(semaphore);<br>    &#125;];<br><br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br><br>    <span class="hljs-keyword">return</span> tasks;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面实现一个线程同步，即将异步操作转换为按一定顺序执行的同步任务</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;currentThread---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);  <span class="hljs-comment">// 打印当前线程</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;semaphore---begin&quot;</span>);<br><br><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br>dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">0</span>);<br><br>__block <span class="hljs-type">int</span> number = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    <span class="hljs-comment">// 追加任务 1</span><br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2</span>];              <span class="hljs-comment">// 模拟耗时操作</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1---%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);      <span class="hljs-comment">// 打印当前线程</span><br>    <br>    number = <span class="hljs-number">100</span>;<br>    <br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br><br>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;semaphore---end,number = %zd&quot;</span>,number);<br><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">22</span>:<span class="hljs-number">03</span>:<span class="hljs-number">24</span>.<span class="hljs-number">306870</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">32951</span>:<span class="hljs-number">1054415</span>] currentThread---&lt;_NSMainThread: <span class="hljs-number">0</span>x6000017a8800&gt;&#123;number = <span class="hljs-number">1</span>, name = main&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">22</span>:<span class="hljs-number">03</span>:<span class="hljs-number">24</span>.<span class="hljs-number">306913</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">32951</span>:<span class="hljs-number">1054415</span>] semaphore---begin<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">22</span>:<span class="hljs-number">03</span>:<span class="hljs-number">26</span>.<span class="hljs-number">312184</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">32951</span>:<span class="hljs-number">1054615</span>] <span class="hljs-number">1</span>---&lt;NSThread: <span class="hljs-number">0</span>x6000017a4980&gt;&#123;number = <span class="hljs-number">4</span>, name = (null)&#125;<br><span class="hljs-attribute">2022</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span> <span class="hljs-number">22</span>:<span class="hljs-number">03</span>:<span class="hljs-number">26</span>.<span class="hljs-number">312500</span>+<span class="hljs-number">0800</span> DemoForGCD[<span class="hljs-number">32951</span>:<span class="hljs-number">1054415</span>] semaphore---end,number = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>从结果可以看出，执行顺序如下：创建信号量时初始化为0；异步执行将任务追加到队列中，不做等待，继续执行wait方法，此时semaphore-1 等于-1，当前线程阻塞。异步任务开始执行，执行到signal方法时，semaphore+1 等于0，被阻塞的线程恢复执行，打印end，这就实现了将异步操作转成同步操作。</p><h3 id="6-7-2-线程安全"><a href="#6-7-2-线程安全" class="headerlink" title="6.7.2 线程安全"></a>6.7.2 线程安全</h3><ul><li><p>线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></li><li><p>线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p></li></ul><p>思考以下情况：使用global队列更新NSMutableArray对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">NSMutableArray</span> *array = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        [array addObject:[<span class="hljs-built_in">NSNumber</span> numberWithInt:i]];<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果果然报错了，应该使用信号量</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">DemoForGCD(<span class="hljs-number">30341</span>,<span class="hljs-number">0x16bd5f000</span>) malloc: Heap corruption detected, <span class="hljs-keyword">free</span> list is damaged at <span class="hljs-number">0x6000005dc210</span><br><span class="hljs-comment">*** Incorrect guard value: 216172790074170281</span><br>DemoForGCD(<span class="hljs-number">30341</span>,<span class="hljs-number">0x16bd5f000</span>) malloc: *** <span class="hljs-keyword">set</span> a <span class="hljs-comment">breakpoint in malloc_error_break to debug</span><br></code></pre></td></tr></table></figure><p>使用信号量完善之前的代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">dispatch_queue_t </span>queue = <span class="hljs-keyword">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, </span><span class="hljs-number">0</span>);<br><br>NSMutableArray *array = [[NSMutableArray alloc] init];<br><br><span class="hljs-keyword">dispatch_semaphore_t </span>semaphore = <span class="hljs-keyword">dispatch_semaphore_create(1);</span><br><span class="hljs-keyword"></span>for(int i=<span class="hljs-number">0</span><span class="hljs-comment">; i&lt;100;i++)&#123;</span><br>    <span class="hljs-keyword">dispatch_async(queue, </span>^&#123;<br>        <span class="hljs-keyword">dispatch_semaphore_wait(semaphore, </span><span class="hljs-keyword">DISPATCH_TIME_FOREVER);</span><br><span class="hljs-keyword"></span>        [array <span class="hljs-keyword">addObject:[NSNumber </span>numberWithInt:i]];<br>        NSLog(@<span class="hljs-string">&quot;add&quot;</span>);<br>        <span class="hljs-keyword">dispatch_semaphore_signal(semaphore);</span><br><span class="hljs-keyword"></span>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><em>文章参考：</em></p><ul><li><a href="https://juejin.cn/post/6844903566398717960">iOS多线程：『GCD』详尽总结</a></li><li>《Objective-C高级编程 iOS与OS X 多线程内存管理》</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS 多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS内存管理之ARC</title>
    <link href="/2022/05/25/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/05/25/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h1><p>自动引用计数(ARC，Automatic Reference Counting)是指内存管理中对引用采取自动计数的技术。</p><p>在了解ARC技术之前，先了解如何手工管理内存。</p><h3 id="手动引用计数"><a href="#手动引用计数" class="headerlink" title="手动引用计数"></a>手动引用计数</h3><p><img src="/../img/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1.png"></p><table><thead><tr><th>方法</th><th>对象操作</th></tr></thead><tbody><tr><td>alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy</td><td>生成并持有对象</td></tr><tr><td>retain</td><td>持有对象</td></tr><tr><td>release</td><td>释放对象</td></tr><tr><td>dealloc</td><td>销毁对象</td></tr></tbody></table><h4 id="自己生成的对象自己持有"><a href="#自己生成的对象自己持有" class="headerlink" title="自己生成的对象自己持有"></a>自己生成的对象自己持有</h4><p>使用以下方法意味着自己生成的对象自己持有：</p><ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy</li></ul><ol><li>alloc方法<figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">id obj <span class="hljs-operator">=</span> [[NSObject alloc] init]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>使用NSObject类的alloc类方法能够生成并持有对象，指向生成对象并持有该对象的指针赋给变量obj</li><li>new方法<br>和alloc也能生成并持有对象 效果和alloc一致<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">id obj <span class="hljs-operator">=</span> [[NSObject new] init]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>copy方法<br>copy方法是基于NSCopying类的copyWithZone:方法，生成并持有对象的副本。</li><li>mutableCopy方法<br>mutableCopy方法和copy方法差不多，是基于NSMutableCoping类的mutableCopyWithZone:方法，生成并持有对象的副本。<br>两者的区别在于，copy方法生成不可变的对象，mutableCopy方法生成可以改变的对象</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AFNetworking源码解析（一）</title>
    <link href="/2022/05/19/AFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/05/19/AFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>AFNetworking是对iOS中⽹络请求⽅式NSURLSession的封装。</p><blockquote><p><a href="https://goggles-zoom.vercel.app/2022/05/19/NSURLSession%E8%AF%A6%E8%A7%A3/">Blog:NSURLSession详解</a></p></blockquote><h2 id="AFNetworking框架结构"><a href="#AFNetworking框架结构" class="headerlink" title="AFNetworking框架结构"></a>AFNetworking框架结构</h2><blockquote><p>本文以4.0版本为例</p></blockquote><p>AFNetworking框架主要分为五个模块：分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成</p><ol><li>NSURLSession：⽹络通信模块，对应着AFNetworking中的<code>AFURLSessionManager</code>和对HTTP协议进行特化处理的<code>AFHTTPSessionManager</code>，其中<code>AFHTTPSessionManager</code>继承自<code>AFURLSessionManager</code>。</li><li>Reachability： ⽹络状态监听模块，对应着AFNetworking中的<code>AFNetworkReachabilityManager</code></li><li>Security： ⽹络通讯安全策略模块，对应着AFNetworking中的AFSecurityPolicy</li><li>Serialization：信息序列化模块，对应着AFNetworking中的<code>AFURLResponseSerialization</code>和<code>AFURLRequestSerialization</code></li><li>UIKit：是UIKit的扩展库</li></ol><h1 id="AFURLSessionManager分析"><a href="#AFURLSessionManager分析" class="headerlink" title="AFURLSessionManager分析"></a>AFURLSessionManager分析</h1><p>因为AFURLSessionManager是对NSURLSession的封装，因此回顾一下，NSURLSession的流程：</p><ol><li>创建NSURLSessionConfiguration对象，配置session的各种属性</li><li>利用configuration创建session，这里有三个类方法可以实现</li><li>根据需求选择task的类型，用session创建task</li><li>resume task</li><li>用delegate方法或completion block 响应网络事件及数据<br>每次网络会话（可以简单理解为一个网页）对应一个session对象，每个session对象可以创建多个task来完成交互。</li></ol><h2 id="AFURLSessionManager属性"><a href="#AFURLSessionManager属性" class="headerlink" title="AFURLSessionManager属性"></a>AFURLSessionManager属性</h2><p>通过查看AFURLSessionManager.h头文件，可以看到主要的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></div></td><td class="code"><pre><code class="hljs Objective-C">//AFURLSessionManager类实现了许多NSURLSession相关的delegate协议，用于处理数据<br>@interface AFURLSessionManager : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying&gt;<br>/**<br> The managed session. 管理的session对象，AFN发起的网络请求都是该session去创建task实例<br> */<br>@property (readonly, nonatomic, strong) NSURLSession *session;<br><br>/**<br> The operation queue on which delegate callbacks are run. delegate回调的操作队列<br> */<br>@property (readonly, nonatomic, strong) NSOperationQueue *operationQueue;<br><br>/**<br> Responses sent from the server in data tasks created with `dataTaskWithRequest:success:failure:` and run using the `GET` / `POST` / et al. convenience methods are automatically validated and serialized by the response serializer. By default, this property is set to an instance of `AFJSONResponseSerializer`.<br><br> @warning `responseSerializer` must not be `nil`.<br> 解析网络返回数据的对象<br> */<br>@property (nonatomic, strong) id &lt;AFURLResponseSerialization&gt; responseSerializer;<br><br>///-------------------------------<br>/// @name Managing Security Policy<br>///-------------------------------<br><br>/**<br> The security policy used by created session to evaluate server trust for secure connections. `AFURLSessionManager` uses the `defaultPolicy` unless otherwise specified.<br> 用于处理网络连接安全处理策略的AFSecurityPolicy对象<br> */<br>@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;<br><br>#if !TARGET_OS_WATCH<br>///--------------------------------------<br>/// @name Monitoring Network Reachability<br>///--------------------------------------<br>/**<br> The network reachability manager. `AFURLSessionManager` uses the `sharedManager` by default.<br> 用于检测网络数据的AFNetworkReachabilityManager对象<br> */<br>@property (readwrite, nonatomic, strong) AFNetworkReachabilityManager *reachabilityManager;<br>#endif<br><br>///----------------------------<br>/// @name Getting Session Tasks<br>///----------------------------<br><br>/**<br> The data, upload, and download tasks currently run by the managed session.<br> session管理的所有task的集合<br> */<br>@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionTask *&gt; *tasks;<br><br>/**<br> The data tasks currently run by the managed session.<br> session管理的data task的集合<br> */<br>@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDataTask *&gt; *dataTasks;<br><br>/**<br> The upload tasks currently run by the managed session.<br> session管理的upload task的集合<br> */<br>@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionUploadTask *&gt; *uploadTasks;<br><br>/**<br> The download tasks currently run by the managed session.<br> session管理的download task的集合<br> */<br>@property (readonly, nonatomic, strong) NSArray &lt;NSURLSessionDownloadTask *&gt; *downloadTasks;<br><br>///-------------------------------<br>/// @name Managing Callback Queues<br>///-------------------------------<br><br>/**<br> The dispatch queue for `completionBlock`. If `NULL` (default), the main queue is used.<br> 完成为例请求后执行的回调块的队列，如果是nil就使用主队列<br> */<br>@property (nonatomic, strong, nullable) dispatch_queue_t completionQueue;<br><br>/**<br> The dispatch group for `completionBlock`. If `NULL` (default), a private dispatch group is used.<br> */<br>@property (nonatomic, strong, nullable) dispatch_group_t completionGroup;<br><br></code></pre></td></tr></table></figure><h2 id="AFURLSessionManager的方法"><a href="#AFURLSessionManager的方法" class="headerlink" title="AFURLSessionManager的方法"></a>AFURLSessionManager的方法</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//指定初始化方法，根据传入的configuration创建session实例</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithSessionConfiguration:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURLSessionConfiguration</span> *)configuration <span class="hljs-built_in">NS_DESIGNATED_INITIALIZER</span>;<br><br> <span class="hljs-comment">//设置session无效，cancelPendingTasks：是否取消seesion中正在执行的任务；resetSession：是否重置session</span><br> <span class="hljs-comment">//具体实现中还是调用了NSURLSession的`invalidateAndCancel` `finishTasksAndInvalidat`方法</span><br>- (<span class="hljs-type">void</span>)invalidateSessionCancelingTasks:(<span class="hljs-type">BOOL</span>)cancelPendingTasks resetSession:(<span class="hljs-type">BOOL</span>)resetSession;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  根据具体的request创建一个`NSURLSessionDataTask`对象，需要注意的是，uploadProgressBlock 和 downloadProgressBlock 是在session queue被调用不是在main queue</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                               uploadProgress:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> *uploadProgress))uploadProgressBlock<br>                             downloadProgress:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> *downloadProgress))downloadProgressBlock<br>                            completionHandler:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-type">id</span> _Nullable responseObject,  <span class="hljs-built_in">NSError</span> * _Nullable error))completionHandler;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 根据具体的request创建一个`NSURLSessionUploadTask`对象，fileURL：本地需要上传文件的url</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                                         fromFile:(<span class="hljs-built_in">NSURL</span> *)fileURL<br>                                         progress:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> *uploadProgress))uploadProgressBlock<br>                                completionHandler:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-type">id</span> _Nullable responseObject, <span class="hljs-built_in">NSError</span>  * _Nullable error))completionHandler;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 根据指定的request和body创建`NSURLSessionUploadTask`</span><br><span class="hljs-comment"> bodyData：需要上传到http body的data</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                                         fromData:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSData</span> *)bodyData<br>                                         progress:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> *uploadProgress))uploadProgressBlock<br>                                completionHandler:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-type">id</span> _Nullable responseObject, <span class="hljs-built_in">NSError</span> * _Nullable error))completionHandler;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 根据指定的stream request创建`NSURLSessionUploadTask`</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                                                 progress:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> *uploadProgress))uploadProgressBlock<br>                                        completionHandler:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-type">id</span> _Nullable responseObject, <span class="hljs-built_in">NSError</span> * _Nullable error))completionHandler;<br><br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 根据指定的request创建`NSURLSessionDownloadTask`</span><br><span class="hljs-comment"> destination：为确定下载文件的destination而执行的块对象，接收两个参数：target path &amp; server response，并返回下载文件的url</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//需要注意：如果后台会话使用configuration，则当应用终止的时候这个block会丢失。因此后台会话更倾向于用`-setDownloadTaskDidFinishDownloadingBlock:` 来保存下载文件的url</span><br>- (<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                                             progress:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> *downloadProgress))downloadProgressBlock<br>                                          destination:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURL</span> * (^)(<span class="hljs-built_in">NSURL</span> *targetPath, <span class="hljs-built_in">NSURLResponse</span> *response))destination<br>                                    completionHandler:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-built_in">NSURL</span> * _Nullable filePath, <span class="hljs-built_in">NSError</span> * _Nullable error))completionHandler;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 根据指定的resume data创建`NSURLSessionDownloadTask`</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithResumeData:(<span class="hljs-built_in">NSData</span> *)resumeData<br>                                                progress:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSProgress</span> *downloadProgress))downloadProgressBlock<br>                                             destination:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURL</span> * (^)(<span class="hljs-built_in">NSURL</span> *targetPath, <span class="hljs-built_in">NSURLResponse</span> *response))destination<br>                                       completionHandler:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-built_in">NSURL</span> * _Nullable filePath, <span class="hljs-built_in">NSError</span> * _Nullable error))completionHandler;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">返回指定任务的NSProcess类型的上传进度</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSProgress</span> *)uploadProgressForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">返回指定任务的NSProcess类型的下载进度</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSProgress</span> *)downloadProgressForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置session无效时执行的回调块，</span><br><span class="hljs-comment">由`NSURLSessionDelegate` 中的`URLSession:didBecomeInvalidWithError:`来处理</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setSessionDidBecomeInvalidBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSError</span> *error))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置seesion接收到身份验证时执行的回调块，</span><br><span class="hljs-comment">由`NSURLSessionDelegate` 中的`URLSession:didReceiveChallenge:completionHandler:`来处理</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param block 发生身份验证要执行的对象块，返回身份验证的处置，接收三个参数：session、challenge、指向用于解决challenge的指针</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setSessionDidReceiveAuthenticationChallengeBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="hljs-built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置session需要新的stream时执行的回调块，</span><br><span class="hljs-comment">由`NSURLSessionTaskDelegate` 中的`URLSession:task:needNewBodyStream:`来处理</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setTaskNeedNewBodyStreamBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSInputStream</span> * (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionTask</span> *task))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置session需要重定向时执行的回调块，</span><br><span class="hljs-comment">由`NSURLSessionTaskDelegate` 中的`URLSession:willPerformHTTPRedirection:newRequest:completionHandler:`来处理</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @param block 该block返回重定向后的request，接收四个参数：session、task、重定向的response、接收重定向后的request</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setTaskWillPerformHTTPRedirectionBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURLRequest</span> * _Nullable (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionTask</span> *task, <span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-built_in">NSURLRequest</span> *request))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Sets a block to be executed when a session task has received a request specific authentication challenge, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didReceiveChallenge:completionHandler:`.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param authenticationChallengeHandler A block object to be executed when a session task has received a request specific authentication challenge.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> When implementing an authentication challenge handler, you should check the authentication method first (`challenge.protectionSpace.authenticationMethod `) to decide if you want to handle the authentication challenge yourself or if you want AFNetworking to handle it. If you want AFNetworking to handle the authentication challenge, just return `@(NSURLSessionAuthChallengePerformDefaultHandling)`. For example, you certainly want AFNetworking to handle certificate validation (i.e. authentication method == `NSURLAuthenticationMethodServerTrust`) as defined by the security policy. If you want to handle the challenge yourself, you have four options:</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 1. Return `nil` from the authentication challenge handler. You **MUST** call the completion handler with a disposition and credentials yourself. Use this if you need to present a user interface to let the user enter their credentials.</span><br><span class="hljs-comment"> 2. Return an `NSError` object from the authentication challenge handler. You **MUST NOT** call the completion handler when returning an `NSError `. The returned error will be reported in the completion handler of the task. Use this if you need to abort an authentication challenge with a specific error.</span><br><span class="hljs-comment"> 3. Return an `NSURLCredential` object from the authentication challenge handler. You **MUST NOT** call the completion handler when returning an `NSURLCredential`. The returned credentials will be used to fulfil the challenge. Use this when you can get credentials without presenting a user interface.</span><br><span class="hljs-comment"> 4. Return an `NSNumber` object wrapping an `NSURLSessionAuthChallengeDisposition`. Supported values are `@(NSURLSessionAuthChallengePerformDefaultHandling)`, `@(NSURLSessionAuthChallengeCancelAuthenticationChallenge)` and `@(NSURLSessionAuthChallengeRejectProtectionSpace)`. You **MUST NOT** call the completion handler when returning an `NSNumber`.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> If you return anything else from the authentication challenge handler, an exception will be thrown.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> For more information about how URL sessions handle the different types of authentication challenges, see [NSURLSession](https://developer.apple.com/reference/foundation/nsurlsession?language=objc) and [URL Session Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html).</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @see -securityPolicy</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setAuthenticationChallengeHandler:(<span class="hljs-type">id</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionTask</span> *task, <span class="hljs-built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="hljs-type">void</span> (^completionHandler)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> , <span class="hljs-built_in">NSURLCredential</span> * _Nullable)))authenticationChallengeHandler;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Sets a block to be executed periodically to track upload progress, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @param block A block object to be called when an undetermined number of bytes have been uploaded to the server. This block has no return value and takes five arguments: the session, the task, the number of bytes written since the last time the upload progress block was called, the total bytes written, and the total bytes expected to be written during the request, as initially determined by the length of the HTTP body. This block may be called multiple times, and will execute on the main thread.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setTaskDidSendBodyDataBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionTask</span> *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Sets a block to be executed as the last message related to a specific task, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didCompleteWithError:`.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @param block A block object to be executed when a session task is completed. The block has no return value, and takes three arguments: the session, the task, and any error that occurred in the process of executing the task.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setTaskDidCompleteBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionTask</span> *task, <span class="hljs-built_in">NSError</span> * _Nullable error))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Sets a block to be executed when metrics are finalized related to a specific task, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didFinishCollectingMetrics:`.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @param block A block object to be executed when a session task is completed. The block has no return value, and takes three arguments: the session, the task, and any metrics that were collected in the process of executing the task.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> AF_CAN_INCLUDE_SESSION_TASK_METRICS</span><br>- (<span class="hljs-type">void</span>)setTaskDidFinishCollectingMetricsBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionTask</span> *task, <span class="hljs-built_in">NSURLSessionTaskMetrics</span> * _Nullable metrics))block AF_API_AVAILABLE(ios(<span class="hljs-number">10</span>), macosx(<span class="hljs-number">10.12</span>), watchos(<span class="hljs-number">3</span>), tvos(<span class="hljs-number">10</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">///-------------------------------------------</span><br><span class="hljs-comment">/// @name Setting Data Task Delegate Callbacks</span><br><span class="hljs-comment">///-------------------------------------------</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Sets a block to be executed when a data task has received a response, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:didReceiveResponse:completionHandler:`.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @param block A block object to be executed when a data task has received a response. The block returns the disposition of the session response, and takes three arguments: the session, the data task, and the received response.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setDataTaskDidReceiveResponseBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURLSessionResponseDisposition</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask, <span class="hljs-built_in">NSURLResponse</span> *response))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Sets a block to be executed when a data task has become a download task, as handled by the `NSURLSessionDataDelegate` method `URLSession:dataTask:didBecomeDownloadTask:`.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @param block A block object to be executed when a data task has become a download task. The block has no return value, and takes three arguments: the session, the data task, and the download task it has become.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setDataTaskDidBecomeDownloadTaskBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask, <span class="hljs-built_in">NSURLSessionDownloadTask</span> *downloadTask))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置当data task接收到数据时的回调块</span><br><span class="hljs-comment">由`NSURLSessionDataDelegate` 中的`URLSession:dataTask:didReceiveData:`来处理</span><br><span class="hljs-comment">需要注意该block会多次执行，并且在session manager operation queue上执行</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setDataTaskDidReceiveDataBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask, <span class="hljs-built_in">NSData</span> *data))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置决定data task缓存的回调块</span><br><span class="hljs-comment">由`NSURLSessionDataDelegate` 中的`URLSession:dataTask:willCacheResponse:completionHandler:`来处理</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setDataTaskWillCacheResponseBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSCachedURLResponse</span> * (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask, <span class="hljs-built_in">NSCachedURLResponse</span> *proposedResponse))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置会话中排队的所有消息都已交付时的回调块</span><br><span class="hljs-comment">由`NSURLSessionDelegate` 中的`URLSessionDidFinishEventsForBackgroundURLSession:`来处理</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setDidFinishEventsForBackgroundURLSessionBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session))block AF_API_UNAVAILABLE(macos);<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置download task下载完成时的回调块</span><br><span class="hljs-comment">由`NSURLSessionDownloadDelegate` 中的`URLSession:downloadTask:didFinishDownloadingToURL:`来处理</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setDownloadTaskDidFinishDownloadingBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSURL</span> * _Nullable  (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionDownloadTask</span> *downloadTask, <span class="hljs-built_in">NSURL</span> *location))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置回调块周期性地查看下载进度，</span><br><span class="hljs-comment">由`NSURLSessionDownloadDelegate` 中的`URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`来处理</span><br><span class="hljs-comment">需要注意该block会多次执行，并且在session manager operation queue上执行</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setDownloadTaskDidWriteDataBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">设置当download task ruseme时执行的回调块，</span><br><span class="hljs-comment">由`NSURLSessionDownloadDelegate` 中的`URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`来处理</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)setDownloadTaskDidResumeBlock:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSession</span> *session, <span class="hljs-built_in">NSURLSessionDownloadTask</span> *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">url_session_manager_processing_queue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">dispatch_queue_t</span> af_url_session_manager_processing_queue;<br>    <span class="hljs-type">static</span> <span class="hljs-type">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        af_url_session_manager_processing_queue = <span class="hljs-built_in">dispatch_queue_create</span>(<span class="hljs-string">&quot;com.alamofire.networking.session.manager.processing&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> af_url_session_manager_processing_queue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">dispatch_group_t</span> <span class="hljs-title">url_session_manager_completion_group</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">dispatch_group_t</span> af_url_session_manager_completion_group;<br>    <span class="hljs-type">static</span> <span class="hljs-type">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        af_url_session_manager_completion_group = <span class="hljs-built_in">dispatch_group_create</span>();<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> af_url_session_manager_completion_group;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>iOS networking 源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSURLSession详解</title>
    <link href="/2022/05/19/NSURLSession%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/05/19/NSURLSession%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="URL-Loading-System"><a href="#URL-Loading-System" class="headerlink" title="URL Loading System"></a>URL Loading System</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="/./../img/URLSession/overview.png" alt="overview"></p><p>URL 加载系统（URL Loading System）使用标准协议（如 https）或自定义协议提供对 URL 标识资源进行访问。URL Loading System 是异步执行的，这样 app 可以保持响应，并在 response 到达时处理数据或错误。<br>使用URLSession实例创建一个或多个URLSessionTask实例，URLSessionTask实例可以拉取数据并将数据返回到 app、下载文件，或将文件、数据上传到远程服务器。使用URLSessionConfiguration对象配置URLSession的实例 session（会话），URLSessionConfiguration对象可以配置 caches、cookies 策略，以及是否允许使用数据流量等。<br>可以使用一个 session 重复创建 task。例如，浏览器为正常浏览和无痕模式使用单独的 session，无痕浏览不会保存数据到磁盘。</p><h2 id="2-URLSessionConfiguration"><a href="#2-URLSessionConfiguration" class="headerlink" title="2 URLSessionConfiguration"></a>2 URLSessionConfiguration</h2><p>URLSessionConfiguration相当于是管家，负责为seesion配置在网络交互过程中的各种属性。<br>URLSessionConfiguration 允许通过各种属性来设置configuration，包括setting cookie policies、setting security policies、setting caching policies、Setting HTTP Policy and Proxy Properties、Supporting Background Transfers等</p><p><img src="/./../img/URLSession/%E5%B1%9E%E6%80%A7.png" alt="configuration属性"></p><p>从上图上可以看到常用的属性：<code>allowsCellularAccess</code>–是否允许访问蜂窝网, <code>HTTPMaximumConnectionsPerHost</code>–最大连接数, <code>requestCachePolicy</code>–cache策略等</p><p>apple提供了三种类型的configuration</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs objective-c">@property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration;<br>@property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration;<br>+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));<br></code></pre></td></tr></table></figure><p>官方对这几种类型的configuration的解释：</p><blockquote><ul><li>The singleton shared session (which has no configuration object) is for basic requests. It’s not as customizable as sessions that you create, but it serves as a good starting point if you have very limited requirements. You access this session by calling the shared class method. See that method’s discussion for more information about its limitations.</li><li>Default sessions behave much like the shared session (unless you customize them further), but let you obtain data incrementally using a delegate. You can create a default session configuration by calling the default method on the URLSessionConfiguration class.</li><li>Ephemeral sessions are similar to default sessions, but they don’t write caches, cookies, or credentials to disk. You can create an ephemeral session configuration by calling the ephemeral method on the URLSessionConfiguration class.</li><li>Background sessions let you perform uploads and downloads of content in the background while your app isn’t running. You can create a background session configuration by calling the backgroundSessionConfiguration(_:) method on the URLSessionConfiguration class.</li></ul></blockquote><p>对于shared session和default其实比较相似，只不过default可以自定义一些参数。default，it uses the disk-persisted global cache,credential and cookie storage objects. Ephemeral, store all data in memory.<br>其中<code>backgroundSessionConfiguration:</code>的<code>identifier</code>参数在整个app中必须是唯一的，如果出现重复其后果是严重的！<br>通过该identifier，我们可以创建新的background session，用于获取与其绑定的download or upload response。</p><h2 id="3-URLSessionTask"><a href="#3-URLSessionTask" class="headerlink" title="3 URLSessionTask"></a>3 URLSessionTask</h2><blockquote><p>NSURLSessionTask - a cancelable object that refers to the lifetime of processing a given request.</p></blockquote><p>URLSessionTask是真正干活的人，但他并没有初始方法，必须归属于seesion。<br>URLSessionTask是URL会话任务的抽象类，有四个具体的子类<br><img src="/./../img/URLSession/task.png" alt="3"></p><ul><li><p><code>URLSessionDataTask</code>：Use this task for GET requests to retrieve data from servers to memory.<br>使用 <code>dataTask(with:)</code>方法创建<code>URLSessionDataTask</code>实例，datatask 用于请求资源(如：JSON、XML格式的数据），将服务器的响应作为一个或多个<code>NSData</code>对象返回到内存中。Default、ephemeral、shared session 支持<code>URLSessionDataTask</code>，<code>backgroundsession</code> 不支持<code>URLSessionDataTask</code>。</p></li><li><p><code>URLSessionUploadTask</code>：Use this task to upload a file from disk to a web service via a POST or PUT method.<br>使用 <code>uploadTask(with:from:)</code>方法创建<code>URLSessionUploadTask</code>实例，用于通过HTTP协议向服务器上传数据或文件,URLSessionUploadTask继承自URLSessionDataTask。使用URLSessionUploadTask 可以很方便为 request 提供 body（例如，POST 或 PUT），还可以在收到 response 前上传数据。此外，upload task 支持后台会话。<br>在 iOS 中，为 background session 创建 upload task 时，系统会将文件复制到临时目录，然后从临时目录上传。</p></li><li><p>URLSessionDownloadTask：Use this task to download a file from a remote service to a temporary file location.<br>使用<code>downloadTask(with:)</code>方法创建URLSessionDownloadTask 实例，download task 将资源直接下载到磁盘上的文件。Download task 支持任何类型的会话。download task可以pause、resume</p></li><li><p>URLSessionStreamTask：使用streamTask(withHostName:port:)或streamTask(with:)方法创建URLSessionStreamTask实例。流任务（stream task）从主机、端口或网络服务建立 TCP&#x2F;IP连接。</p></li></ul><p><em>NOTE，在创建完任务之后，需要调用resume 方法才会启动任务。在任务完成或失败前，session 会强引用 task。如果没有特别用途，不需要维护对任务的引用。</em></p><h2 id="4-URLSession"><a href="#4-URLSession" class="headerlink" title="4 URLSession"></a>4 URLSession</h2><h3 id="4-1-URLSession-overview"><a href="#4-1-URLSession-overview" class="headerlink" title="4.1 URLSession overview"></a>4.1 URLSession overview</h3><p>URLSession is both a class and a suite of classes for handling HTTP- and HTTPS-based requests.<br>URLSession是整个体系中的领导。<br><img src="/./../img/URLSession/2.png" alt="2"></p><p><em>NOTE：一个session可以创建多个task，并且session中的所有的task共享configuration</em></p><h3 id="4-2-Create-URLSession"><a href="#4-2-Create-URLSession" class="headerlink" title="4.2 Create URLSession"></a>4.2 Create URLSession</h3><p><a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc#topics">官方文档</a></p><blockquote><p>Configuration options for an NSURLSession.  When a session is created, a copy of the configuration object is made - you cannot modify the configuration of a session after it has been created.</p></blockquote><p>可以通过单例sharedSession来使用session，也可以通过URLSessionConfiguration来创建configuration，配置session。</p><p><strong>创建NSURLSession的三个类方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs obejctive-c">// 使用default configuration并且该session中的task必须提供completionHandler<br>+ (NSURLSession *)sharedSession;<br><br>// 该session中的task必须提供completionHandler<br>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;<br><br>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id&lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(NSOperationQueue *)queue;<br></code></pre></td></tr></table></figure><ul><li>NOTE：</li></ul><ul><li>在创建session的时候会拷贝configuration，并且在创建session之后，不允许修改configuration。</li><li>NSURLSession对delegate是strong reference，直到我们显式地调用 invalidateAndCancel 或 resetWithCompletionHandler:方法。因此，在使用过程中要注意retain cycle。*</li></ul><h2 id="5-URLSessionDelegate"><a href="#5-URLSessionDelegate" class="headerlink" title="5 URLSessionDelegate"></a>5 URLSessionDelegate</h2><blockquote><p>NSURLSessionDelegate specifies the methods that a session delegate may respond to.  There are both session specific messages (for example, connection based auth) as well as task based messages.</p></blockquote><p><img src="/./../img/URLSession/delegate.png" alt="3"></p><p>URLSessionDelegate定义了URLSession实例调用delegate处理session事件的方法。除实现URLSessionDelegate协议内方法，大部分 delegate 还需要实现URLSessionTaskDelegate、URLSessionDataDelegate、URLSessionDownloadDelegate中的一个或多个协议，以便处理 task 级事件，<br>URLSessionDelegate 有三个optional方法</p><ol><li><code>- (void)URLSession: didBecomeInvalidWithError: </code>该方法通知session是否失效<blockquote><p>The last message a session receives.  A session will only become invalid because of a systemic error or when it has been explicitly invalidated, in which case the error parameter will be nil.</p></blockquote></li></ol><p>如果通过调用finishTasksAndInvalidate()方法使会话无效，会话会在最后一个 task 完成或失败后调用该方法<br>如果通过调用invalidateAndCancel()方法使会话无效，会话立即调用该方法。</p><blockquote><p>If implemented, when a connection level authentication challenge has occurred, this delegate will be given the opportunity to provide authentication credentials to the underlying connection. Some types of authentication will apply to more than one request on a given connection to a server (SSL Server Trust challenges). If this delegate message is not implemented, the behavior will be to use the default handling, which may involve user interaction.</p></blockquote><p>2.<code> - (void)URLSession: didReceiveChallenge: completionHandler:</code> 该方法主要是处理远程服务器的会话级身份验证请求。遇到以下两种情况时会调用该方法：</p><ol><li>远程服务器请求客户端证书，或 Windows NT LAN Manager（NTLM）认证时会调用该方法以提供适当的凭据。</li><li>当 session 与使用 SSL 或 TLS 的远程服务器首次建立连接时，使用该方法验证服务器的证书链。<br>如果未实现该方法，session 会调用URLSessionTaskDelegate协议中urlSession(_:task:didReceive:completionHandler:)方法，采用 task 级认证。</li></ol><blockquote><p>If an application has received an application: handleEventsForBackgroundURLSession: completionHandler:  message, the session delegate will receive this message to indicate that all messages previously enqueued for this session have been delivered.  At this time it is safe to invoke the previously stored completion handler, or to begin any internal updates that will result in invoking the completion handler.</p></blockquote><ol start="3"><li><code>- (void)URLSessionDidFinishEventsForBackgroundURLSession:</code></li></ol><h2 id="6-URLSessionTaskDelegate"><a href="#6-URLSessionTaskDelegate" class="headerlink" title="6 URLSessionTaskDelegate"></a>6 URLSessionTaskDelegate</h2><p>URLSessionTaskDelegate协议定义了 URL Session 实例调用 delegate 处理 task 级事件的方法。URLSessionTaskDelegate继承自URLSessionDelegate。</p><h3 id="6-1-处理task生命周期"><a href="#6-1-处理task生命周期" class="headerlink" title="6.1 处理task生命周期"></a>6.1 处理task生命周期</h3><p>当任务完成是会调用<code>- (void)URLSession: task: didCompleteWithError:</code>方法。如果发生错误，error参数会包含失败的原因。</p><h3 id="6-2-处理重定向"><a href="#6-2-处理重定向" class="headerlink" title="6.2 处理重定向"></a>6.2 处理重定向</h3><p>当远程服务器请求http重定向时，会调用<code>- (void)URLSession:task:willPerformHTTPRedirection:newRequest: completionHandler:</code>方法。<br>在该方法内必须调用 completion handler。如果允许重定向，为 completion handler 传入 request 参数；如果需要修改重定向，传入修改后的 request 对象；如果禁止重定向，则参数传 nil，此时得到的 response 就是重定向。</p><h3 id="6-3-处理upload-task"><a href="#6-3-处理upload-task" class="headerlink" title="6.3 处理upload task"></a>6.3 处理upload task</h3><p>上传文件时会定期调用<code>- (void)URLSession: task: didSendBodyData: totalBytesSent: totalBytesExpectedToSend:</code>方法，以显示上传进度。</p><h3 id="6-4-采集数据"><a href="#6-4-采集数据" class="headerlink" title="6.4 采集数据"></a>6.4 采集数据</h3><p>调用 <code>- (void)URLSession: task: didFinishCollectingMetrics:</code>方法，收集task完成的信息。其中materics参数封装了task的指标</p><p><code>URLSessionTaskMetrics</code>类包含以下三个属性：</p><ul><li><code>taskInterval：</code>任务发起至任务完成的时间。</li><li><code>redirectCount：</code>任务执行过程中重定向次数。</li><li><code>transactionMetrics</code>：数组内元素为任务执行期间每个 request-response 事务度量标准。元素类型为URLSessionTaskTransactionMetrics。</li></ul><p><code>URLSessionTaskTransactionMetrics</code>对象封装执行会话任务期间收集的性能指标。每个<code>URLSessionTaskTransactionMetrics</code>对象包含了一个 request 和 response 属性，对应于 task 的 request 和 response。其也包含时间指标（temporal metrics），以fetchStartDate开始，以responseEndDate结束，以及其他特性，例如：networkProtocolName和resourceFetchType</p><p><img src="/./../img/URLSession/4.png" alt="4"></p><p>可以使用该方法查看请求各阶段所占用的时间，优化性能。</p><h2 id="7-URLSessionDataDelegate"><a href="#7-URLSessionDataDelegate" class="headerlink" title="7 URLSessionDataDelegate"></a>7 URLSessionDataDelegate</h2><p><code>URLSessionDataDelegate</code>协议定义了 URL session 实例处理 data task、upload task 任务级事件方法。URLSessionDataDelegate继承自URLSessionTaskDelegate协议。</p><p>Data task 接收到服务器的初始回复（header）时，会调用<code>- (void)URLSession: dataTask：didReceiveResponse:  completionHandler:</code>方法<br>只有在接收到 response header 后需要取消任务，或将任务转变为 download task 时才需要实现该方法。未实现该方法时，默认允许继续传输数据。<br>可以在completionHandler中传入URLSession.ResponseDisposition常量。</p><ul><li><code>URLSession.ResponseDisposition.allow：</code>任务继续作为 data task 执行。</li><li><code>URLSession.ResponseDisposition.cancel：</code>取消任务。</li><li><code>URLSession.ResponseDisposition.becomeDownload：</code>调用<code>urlSession(_:dataTask:didBecome:)</code>方法，创建一个 download task 取代当前的 data task。</li></ul><p>Data task 接收到数据时会调用urlSession(_:dataTask:didReceive:)方法。该方法可能被调用多次，每次调用提供上次调用后的数据，你的 app 负责将所需数据拼接起来。</p><p>Data task 或 upload task 在接收完所有数据后会调用urlSession(_:dataTask:willCacheResponse:completionHandler:)方法，以决定是否将响应存储到缓存中。如果没有实现该方法，则根据会话的 configuration 决定是否保存。该方法的主要用途在于阻止指定 URL 缓存响应，或修改缓存的 userInfo 字典。实现该方法后必须调用 completionHandler，传入 proposed response 或修改后的 response 缓存数据，或nil禁止缓存 response。<br>只有在URLProtocol协议允许缓存 response 时，才会调用该方法。下面所有条件均成立时才会缓存响应：</p><ul><li>请求是 HTTP 或 HTTPS 类型，也可以是支持缓存的自定义网络协议。</li><li>请求成功，即状态码在200至299区间。</li><li>response 来自服务器，而非缓存。</li><li>会话配置允许缓存。</li><li>URLRequest缓存策略允许缓存。</li><li>服务器响应中与缓存相关的 header 允许缓存。</li><li>响应大小足够小，能够进行缓存。例如，如果提供磁盘缓存，则响应不得大于磁盘缓存大小的5%。</li></ul><h2 id="8-CompletionHandler-还是-delegat"><a href="#8-CompletionHandler-还是-delegat" class="headerlink" title="8 CompletionHandler 还是 delegat"></a>8 CompletionHandler 还是 delegat</h2><h3 id="8-1-如何选择"><a href="#8-1-如何选择" class="headerlink" title="8.1 如何选择"></a>8.1 如何选择</h3><p>前文说到的用于创建URLSeeion的类方法中，一个需要delegate，两个需要completionHandler。那么什么时候用delegate什么时候用completionHandler？</p><p>以下情况需要提供completionHandler，其余情况可以交给delegate处理</p><ul><li>当App处于background、suspended以及out-of-process状态时，需要由background sessions上传或下载数据；</li><li>自定义网络鉴权；</li><li>自定义SSL验证；</li><li>由服务器返回的MIME type决定一个网络传输是下载到磁盘还是直接display；</li><li>通过body stream上传数据；</li><li>自定义cache；</li><li>自定义HTTP redirects；</li></ul><h3 id="8-2-区别"><a href="#8-2-区别" class="headerlink" title="8.2 区别"></a>8.2 区别</h3><p><img src="/./../img/URLSession/5.png" alt="5"><br>完成处理程序需要处理以下三件事：</p><ol><li>验证 error 参数是否为 nil。如果不为 nil，则传输时发生错误。此时应处理错误并退出。</li><li>检查响应的状态码（status code）是否指示成功，以及 MIME 类型是否为预期值。如果不符合，处理服务器错误并退出。</li><li>根据需要使用返回的 data。</li></ol><p><img src="/./../img/URLSession/6.png" alt="6"></p><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>使用NSURLSession加载数据流程：<br>0. 创建configuration</p><ol><li>创建session</li><li>通过url和参数创建task</li><li>调用resume开始task</li><li>在handler、delegate中处理回调</li></ol><p>参考：</p><ul><li><a href="https://www.youtube.com/watch?v=zvfViYmETuc&t=8s">YouTube视频</a></li><li><a href="https://github.com/pro648/tips/wiki/URLSession%e8%af%a6%e8%a7%a3">URLSession详解 · pro648&#x2F;tips Wiki</a></li><li><a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started">URLSession Tutorial: Getting Started</a></li><li><a href="http://zxfcumtcs.github.io/2014/08/02/NSUrlSession/">NSURLSession——网络框架新生代</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS文件系统</title>
    <link href="/2022/05/13/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/05/13/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS文件系统"><a href="#iOS文件系统" class="headerlink" title="iOS文件系统"></a>iOS文件系统</h1><h2 id="1-iOS系统的沙盒机制"><a href="#1-iOS系统的沙盒机制" class="headerlink" title="1.iOS系统的沙盒机制"></a>1.iOS系统的沙盒机制</h2><p>在iOS系统中，应用程序只能在自己创建的文件系统中读取文件，这种独立、封闭、安全的空间称为沙盒，<br>沙盒机制是iOS系统的一种安全手段。</p><p>沙盒模型下有四个主要的目录：<br><img src="/../img/%E6%B2%99%E7%9B%92.png"></p><ul><li>App：是应用程序的程序包目录，包括应用程序的二进制文件、资源文件和plist等，由于应用程序必须经过签名，所以在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动，故该目录为只读</li><li>Documents：存放需要持久的数据，该目录会被iTunes&#x2F;iCloud备份<ul><li>特点：支持用户数据共享</li></ul></li><li>Tmp：存放临时文件的目录，当应用程序退出之后，会自动清除</li><li>Library：<ul><li>Caches：存放应用程序运行时生成的数据，即缓存，比如音乐缓存，图片缓存等，用户使用过程中的缓存都可以保存在这个目录中，可用于保存可再生文件，应用程序也需要负责删除这些文件，不会自动清除也不会参与备份。</li><li>Preferecnces：存放应用程序的偏好设置，使用NSUserDefault存取，该目录会被iTunes&#x2F;iCloud备份。</li><li>注意，并不是说Library下只有这两个子文件夹，后续会生成各种子文件夹如Cookies等</li><li>特点：可以自定义子文件夹</li></ul></li></ul><blockquote><p>真实目录结构是 在&#x2F;data&#x2F;Containers 文件下有两个子文件夹，分别为Bundle、Data。其中，</p><ul><li>Bundle存放着程序的plist和 xxx.app</li><li>Data下有Documents、Library、SystemData、tmp子文件夹<br><img src="/../img/bundle.png"><br><img src="/../img/data.png"></li></ul></blockquote><h2 id="2-获取文件地址"><a href="#2-获取文件地址" class="headerlink" title="2.获取文件地址"></a>2.获取文件地址</h2><p>主要是使用NSPathUtilities</p><figure class="highlight objectivec"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 获取沙盒主目录路径</span><br><span class="hljs-built_in">NSString</span> *homeDir = <span class="hljs-built_in">NSHomeDirectory</span>(); <br><br><span class="hljs-comment">// 获取Documents目录路径</span><br><span class="hljs-built_in">NSString</span> *docDir = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSDocumentDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) firstObject];<br><br><span class="hljs-comment">// 获取Library的目录路径</span><br><span class="hljs-built_in">NSString</span> *libDir = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSLibraryDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) lastObject];<br><br><span class="hljs-comment">// 获取Caches目录路径</span><br><span class="hljs-built_in">NSString</span> *cachesDir = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSCachesDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) firstObject];<br><br><span class="hljs-comment">// 获取tmp目录路径</span><br><span class="hljs-built_in">NSString</span> *tmpDir =  <span class="hljs-built_in">NSTemporaryDirectory</span>();<br><br><span class="hljs-comment">//应用程序程序包的路径</span><br>[[<span class="hljs-built_in">NSBundle</span> mainBundle] bundlePath]<br><br></code></pre></td></tr></table></figure><h2 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h2><p>主要是用NSFileHandler和NSFileManager</p><h3 id="NSFileHandler"><a href="#NSFileHandler" class="headerlink" title="NSFileHandler"></a>NSFileHandler</h3><p>主要负责对文件内容进行操作</p><ul><li>读取文件&amp;写文件</li><li>读取指定长度的*在指定位置追加&#x2F;截断</li><li>截断&#x2F;刷新</li><li>常用鱼追加数据</li></ul><p>创建</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm">+ (nullable instance<span class="hljs-keyword">type</span>)fileHandleForReadingAtPath:(<span class="hljs-type">NSString</span> *)path;<br><br>+ (nullable instance<span class="hljs-keyword">type</span>)fileHandleForWritingAtPath:(<span class="hljs-type">NSString</span> *)path;<br><br>+ (nullable instance<span class="hljs-keyword">type</span>)fileHandleForUpdatingAtPath:(<span class="hljs-type">NSString</span> *)path;<br></code></pre></td></tr></table></figure><p>读&amp;写</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSData</span> *)readDataToEndOfFile;<br><br>- (<span class="hljs-built_in">NSData</span> *)readDataOfLength:(<span class="hljs-built_in">NSUInteger</span>)length;<br><br>- (<span class="hljs-type">void</span>)writeData:(<span class="hljs-built_in">NSData</span> *)data;<br><br>- (<span class="hljs-type">void</span>)seekToFileOffset:(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)offset<br><br></code></pre></td></tr></table></figure><h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><p>通过NSURL或者NSString作为Path,主要是对文件进行管理</p><ul><li>单例，提供app内文件&amp;文件夹的管理</li><li>创建、删除、查询、移动、复制文件等</li><li>读取文件内容和属性</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)createDirectoryAtPath:(<span class="hljs-built_in">NSString</span> *)path withIntermediateDirectories:(<span class="hljs-type">BOOL</span>)createIntermediates attributes:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSFileAttributeKey</span>, <span class="hljs-type">id</span>&gt; *)attributes error:(<span class="hljs-built_in">NSError</span> **)error;<br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)contentsOfDirectoryAtPath:(<span class="hljs-built_in">NSString</span> *)path error:(<span class="hljs-built_in">NSError</span> **)error;<br><br>- (<span class="hljs-type">BOOL</span>)fileExistsAtPath:(<span class="hljs-built_in">NSString</span> *)path;<br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSData</span> *)contentsAtPath:(<span class="hljs-built_in">NSString</span> *)path;<br><br>- (<span class="hljs-type">BOOL</span>)removeItemAtPath:(<span class="hljs-built_in">NSString</span> *)path error:(<span class="hljs-built_in">NSError</span> **)error;<br></code></pre></td></tr></table></figure><h4 id="NSFileManagerDelegate"><a href="#NSFileManagerDelegate" class="headerlink" title="NSFileManagerDelegate"></a>NSFileManagerDelegate</h4><p>提供移动、复制、删除等操作的具体自定义实现 </p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS 文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS编程</title>
    <link href="/2022/05/06/iOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/06/iOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Objective-C-基础语法"><a href="#Objective-C-基础语法" class="headerlink" title="Objective-C 基础语法"></a>Objective-C 基础语法</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是iOS开发者必须遵守的一个设计模式</p><ul><li>模型Model：负责存储数据，与用户界面无关</li><li>视图View：负责显示界面，与模型无关</li><li>控制器Controller：负责确保视图对象和模型对象的数据一致性</li></ul><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><blockquote><p>当某个对象初始化完成了，就可以向其发送消息，消息需要包括三个部分</p><ul><li>receiver接收方：是一个指针，指向执行方法的对象</li><li>selector选择器：需要执行方法的方法名</li><li>arguments实参：以变量形式传递给方法的数值</li></ul></blockquote><p><code>[person sayHi:someName];</code> 向Person类的实例对象person发送sayHi消息，该消息会触发person的sayHi方法，并传入参数someName<br><code>[person sayHi:someName       withGift:someGift];</code>  这条消息接受多个实参，每个实参都会和选择其中的对应的标签配对，每个标签以冒号结束。</p><p><strong>NOTE：所有的标签合在一起才构成一个selector，并且即使有多个标签，但是仍然只触发了一个方法，即sayHi：withGift：方法</strong></p><p>在OC中，方法的唯一性只取决于方法名，即使参数类型返回值类型不同，一个类也不允许出现两个名称相同的方法。<br><em>NOTE：在OC中，需要注意方法和消息的区别，方法指的是一块可执行的代码，消息指的是要求类或者实例对象执行某个方法的动作。</em></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在OC中数组包含的对象不是对象本身，而是指向对象的指针，即数组保存对象的内存地址。<br>NSMutableArray是NSArray的子类，可以动态的添加删除元素。<br>使用<code>addObject:</code> 尾插法添加元素 <code>insertObject:atIndex:</code> 在执行位置加入元素<br><code>objectAtIndex: </code>访问执行位置的元素    <code>count</code> 返回数组元素的个数<br>快速枚举（fast enumeration）</p><figure class="highlight scss"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(NSString *item in array)&#123;<br>    <span class="hljs-built_in">NSL</span>(xxx);<br>&#125;   <br></code></pre></td></tr></table></figure><p><strong>NOTE：需要注意的是，使用fast enumreation的时候，不能在循环体内添加或者删除元素，会报并发修改异常</strong></p><h4 id="深入学习数组"><a href="#深入学习数组" class="headerlink" title="深入学习数组"></a>深入学习数组</h4><p>OC中数组可以存储不同类型的对象，因为存的是对象的指针（指针大小一致），不像其他强类型语言只能保存一种类型的对象。并且因为数组存的是对象的指针，因此基本类型不能存，需要包装成<code>NSNumber</code>、<code>NSValue</code>、<code>NSData</code>等<br>需要注意数组不能存nil，需要将nil转成NSNull对象<br>访问数组对象的时候，可以使用下标语法<br><code> [items objectAtIndex:3] == items[3]</code> </p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CItem</span> : <span class="hljs-title">NSObject</span></span><br>&#123;<br>    <span class="hljs-built_in">NSString</span> *_itemNAme;<br>    <span class="hljs-built_in">NSString</span> *_serialNumber;<br>    <span class="hljs-type">int</span> _valueInDollars;<br>    <span class="hljs-built_in">NSDate</span> *_dateCreated;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对CItem类来说，每个实例对象包含了一个int类型的数值，和是哪个指向对象的指针。如_itemName指向一个NSString对象，该对象的内容是“RED SOFA”字符串，需要注意的是，_itemName存的是该字符串的地址，而不是字符串本身.</p><h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><p>在OC中，存方法的命名规则：set+要修改的实例变量的变量名，如setItemName；取方法的命名规则：实例变量的变量名，如itemName。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[item setItemName:@&quot;hdhd&quot;]</span><span class="hljs-comment">;</span><br><span class="hljs-section">[item valueInDollars]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>使用dot syntax（点语法）,访问实例对象的存取方法。语法格式：receiver.instance variable。存取方法的用法是相同的，当点语法出现在赋值号左边，表示存方法，出现在赋值号右边表示取方法。点语法是语法糖，编译的时候还是会去调用getter、setter方法</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-type">item</span>.valueInDollars = <span class="hljs-number">5</span>;<br>//equals <span class="hljs-keyword">to</span><br>[<span class="hljs-type">item</span> setValueInDollars:<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><h3 id="self和super关键字"><a href="#self和super关键字" class="headerlink" title="self和super关键字"></a>self和super关键字</h3><ul><li><code>[self method]</code> self存在于方法中，是一个隐式局部变量，程序会自动为self赋值，只想收到消息的对象本身，类似于this。</li><li><code>super method</code>super则是查找父类响应的方法<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3>所有类都是直接或者间接的继承NSObject类，从而都有init方法来初始化对象。可以通过override来重写init方法。任何一个类可以有多个初始化方法，但是必须选择一个作为指定初始化方法（designated initializer）。<br>为什么初始化方法的返回类型是instancetype？这个关键字表示方法的返回类型和调用方法的对象类型相同。之所以返回这种类型是因为，子类就继承init方法，子类执行init方法返回的类型应该是子类类型而不是父类类型（多态性）。<br>id类型，指的是指向任意对象的指针，不仅可以用在返回值类型上也可以用来表示变量和方法参数的类型。注意用id表示指针的时候不需要再加*。<br>在初始化实例变量的时候，一定不要使用存取方法，应该直接访问实例变量。<br>在实现完指定初始化方法之后，其他的初始化方法也要调用指定初始化方法，并传入参数和其他默认值。</li></ul><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>当程序执行某个方法的时候，就会从内存中一个叫栈的空间分配一块内存空间，这个分配的内存叫做帧。帧保存了方法内声明的变量的值（即局部变量），返回地址等，当方法执行完毕之后从栈顶弹出<br>堆Heap：也是内存中的一个区域，和栈是分开的，堆中包含了大量的无序的活动对象，需要通过指针来保存这些对象在堆中的地址。当程序向某个类发送alloc消息的时候，系统就会从堆中分配一块内存存放类声明的实例变量等。堆中的对象不会自动释放，且堆的空间是有限了，因此需要进行内存管理。<br>Apple提供了ARC，即自动引用计数来管理内存，在引入ARC之前都是手动引用计数MRC。</p><h3 id="对象所有权"><a href="#对象所有权" class="headerlink" title="对象所有权"></a>对象所有权</h3><p>指针变量暗含了对其所指的对象的所有权ownership</p><ul><li>当某个方法有一个指向其他对象的局部变量，则称该变量拥有该变量所指的对象</li><li>当某个对象有一个指向其他对象的实例变量，则称该对象拥有该实例变量所指的对象<blockquote><p>如数组存储对象的指针，这些指针暗含了所有权：数组对象拥有了被包含的所有对象。<br>如每个CItem对象拥有实例变量所指的对象。</p></blockquote></li></ul><p>了解对象所有权之后，如果某个对象没有拥有者，就应该将其释放，否则会导致内存泄漏。<br>那么对象在什么情况下会失去拥有者？</p><ol><li>修改指针变量：如_itemName本来指向的对象是@“rusty spork” 后来指向@“shiny sprok” 那么原来的rusty spork就会失去拥有者，因此应该被释放。</li><li>将指针变量的值设为nil：当指针指向nil的时候表示它不再指向其他对象。</li><li>对象的拥有者被释放：对象的拥有者被释放，则会失去一个拥有者。</li><li>从Collection对象中删除对象</li></ol><h3 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h3><ul><li>强引用strong reference：该特性指针变量指向某个对象就会使其多一个拥有者，且不被程序释放。</li><li>弱引用weak reference：该特性指针变量指向某个对象不会使其拥有者个数增加</li></ul><p>弱引用适合解决强引用循环引起的内存泄漏问题，即当两个或者两个以上的对象相互持有强引用特性的指针，会引起强引用循环，对象之间因为相互持有而无法通过ARC机制来释放。<br>在CItem类中，有两个实例变量，_containedItem 、 _container分别表示添加物品和属于其他物品。当实例对象backpack containedItem实例变量指向 实例对象calculator，并且calculator container指向 backpack，这里就存在强引用循环。如果此时将指向两个对象的指针置为nil，则程序无法再使用这两个对象，并且这两个对象会一直占用内存。<br>因此要解决强引用问题，需要先确认对象之间的父子关系，如上面的backpack是父对象，calculator是子对象，父对象的指针为强引用特性，子对象指针为弱引用特性（ _ _ weak修饰变量)</p><h3 id="Autorelease池和ARC"><a href="#Autorelease池和ARC" class="headerlink" title="Autorelease池和ARC"></a>Autorelease池和ARC</h3><ul><li>Autorelease池：当对象收到autorelease消息时，某个自动释放池会成为该对象的临时拥有者。这样就可以解决这类问题：某个方法创建了一个新的对象，但是创建方又不需要成为该对象的拥有者。为了能返回新创建的对象，同时避免提前释放问题，就可以向新创建的对象发送autorelease消息。便捷方法借助自动释放池，将新创建的对象返回给调用方，又不产生内存管理问题。</li><li>如果某个对象不是通过alloc方法或copy方法创建的，就很有可能在返回给调用方前收到过autorelease消息。调用方要根据具体的情况，保留该对象的所有权。否则，在自动释放池被销毁时，程序就会释放这个对象。</li><li>@autoreleasepool指令后面跟一对花括号，可以创建一个自动释放池。在@autoreleasepool的花括号中，如果某个方法返回一个新创建的对象，而该方法的方法名不包含alloc和init，那么这个新创建的对象</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>再引入属性之前，需要为每个类声明一个实例变量并且实现相应地存取方法。引入属性后，通过声明属性就可以完成以上两步，大大减少了代码量且易于理解。</p><h3 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h3><p>语法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (options) 属性类型 属性名称;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>,<span class="hljs-keyword">readwrite</span>) <span class="hljs-built_in">NSString</span> *itemName;<br></code></pre></td></tr></table></figure><p><em>NOTE:编译器会根据属性生成实例变量时会自动在变量名前加上下划线，即属性itemName生成的实例变量为_itemName 取方法itemName和存方法setItemName:</em></p><h3 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h3><ol><li>读写特性 Read&#x2F;write attribute<br>有两种类型可选：readwrite&#x2F;readonly。编译器会根据读写特性生成对应的存取方法，只读特性只生成取方法。</li><li>内存管理特性 Memory management attribute<br>有四种类型可选：strong、waek、copy和unsafe_unretained（非对象属性的默认值）。<ul><li>unsafe_unretained：用于那些不指向任何对象的属性，不需要做内存管理，其存取方法会直接为实例变量赋值。该类型的“不安全”是相对于弱引用而言的。与弱引用不同，unsafe_unretained类型的指针指向的对象被销毁时，指针不会自动设置为nil，而是成为空指针，因此不安全。但是当处理非对象属性（non-object）时，是不会出现空指针问题的。</li><li>对于指向对象的属性，四种类型都有可能，默认是strong类型。当可能存在强引用循环的时候，要将其中的部分属性改成weak，详细看上面。</li><li>当某个属性是指向其他对象的指针，且该对象的类有可修改的子类（NSMutableString、NSMutableArray）时，要将属性设置成copy特性。改成copy之后，存方法会发生一些改变，不是直接将实参赋值给实例变量，而是调用copy方法返回一个新的NSString对象，再赋值给实例变量。这么做是因为，如果属性指向的对象的类有可修改的子类，那么该属性可能会指向可修改的子类对象，同时，该对象可能会被其他拥有者修改。因此，最好先复制该对象，然后再将属性指向复制后的对象。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>)<span class="hljs-built_in">CItem</span> *containedItem;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">weak</span>)<span class="hljs-built_in">CItem</span> *container;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>)<span class="hljs-built_in">NSDate</span> *createDate;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)<span class="hljs-built_in">NSString</span> *itemName;<br><span class="hljs-comment">//_itemName的存方法</span><br>-(<span class="hljs-type">void</span>) setItemName:(<span class="hljs-built_in">NSString</span> *)itemName&#123;<br>    _itemName = [itemName <span class="hljs-keyword">copy</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义属性的存取方法"><a href="#自定义属性的存取方法" class="headerlink" title="自定义属性的存取方法"></a>自定义属性的存取方法</h3>编译器根据属性生成的存取方法都是最简单的存取方法，如果要添加额外的工作，需要覆盖默认方法。当编译器发现有自定义的存方法&#x2F;取方法就不会创建默认的存方法&#x2F;取方法，但仍然会生成没有被覆盖的另一个方法。<br>当存取方法都覆盖，或者只读属性覆盖了取方法，那么编译器不会再生成对应的实例变量，如果需要自己声明。</li></ul></li></ol><h3 id="属性合成"><a href="#属性合成" class="headerlink" title="属性合成"></a>属性合成</h3><p>再头文件中声明属性时，只会生成存取方法的声明，为了让属性生成实例变量和存取方法，属性必须被合成synthesized。默认情况下，编译器会自动合成属性并生成默认的实例变量和存取方法。但如果需要自定义合成方式，要在实现文件中使用@synthesize指令。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 创建存取方法，方法名是age和setAge:，</span><br><br>  　　<span class="hljs-comment">// 同时创建实例变量_age</span><br><br>  　　<span class="hljs-variable">@synthesize</span> age = _age;<br><span class="hljs-comment">//赋值号左边的age表示需要创建存取方法，方法名是age和setAge:。右边的_age表示需要创建实例变量，变量名为_age。</span><br><br><span class="hljs-comment">//也可以不写实例变量的变量名，那么变量名回合方法名相同 </span><br><span class="hljs-comment">//两者等价</span><br><span class="hljs-variable">@synthesize</span> age;<br><span class="hljs-variable">@synthesize</span> age = age;<br></code></pre></td></tr></table></figure><h3 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h3><p>将属性声明在头文件和类扩展中的区别？</p><ul><li>在头文件中声明的属性和方法对其他类是可见的，但有些属性是需要隐藏的</li><li>对于那些只会用在类内部的属性和方法就应该声明在类扩展中。这样就避免了暴露内部实现细节，保证头文件中全是供其他类使用的属性的方法。</li><li>子类无法访问父类在类扩展中声明的属性和方法。</li></ul><h1 id="视图与视图层次结构"><a href="#视图与视图层次结构" class="headerlink" title="视图与视图层次结构"></a>视图与视图层次结构</h1><h2 id="视图层次结构"><a href="#视图层次结构" class="headerlink" title="视图层次结构"></a>视图层次结构</h2><p>一般来说，应用只有一个UIWindow对象，UIWindow作为一个容器，可以包含所有的视图。应用在启动时创建并设置UIWindow对象，并添加其他视图作为子视图，子视图还可以有子视图，因此构成了层次结构。<br><img src="/../img/hierarchy.png" alt="视图层次结构"><br>视图层次结构形成之后，需要将其绘制到屏幕上，绘制的过程可分为两步：</p><ol><li>每个视图分别绘制自己，将自己绘制在图层layer上</li><li>所有的视图的图层组合成一幅图像在绘制到屏幕上。</li></ol><h3 id="frame属性和bounds属性"><a href="#frame属性和bounds属性" class="headerlink" title="frame属性和bounds属性"></a>frame属性和bounds属性</h3><p>在创建UIView的子类之后，通常都会有一个初始化方法<code>initWithFram:(CGRect)frame</code></p><ul><li>视图的frame属性保存的是视图的大小和<strong>相对于父视图的位置</strong>。因为CGRect由CGPoint和CGSize组成。需要注意的是，point的值是相对于父视图的原点坐标。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">frame = CGRectMake(<span class="hljs-number">150</span>,<span class="hljs-number">200</span>,<span class="hljs-number">160</span>,<span class="hljs-number">160</span>);<br><span class="hljs-regexp">//</span>origin(<span class="hljs-number">150</span>,<span class="hljs-number">200</span>) size(<span class="hljs-number">160</span>,<span class="hljs-number">160</span>)<br><span class="hljs-regexp">//</span>origin.x = <span class="hljs-number">150</span> size.height =<span class="hljs-number">160</span>;<br></code></pre></td></tr></table></figure><em>NOTE:这些数值的单位是points不是pixels像素，因为不同屏幕points和分辨率有关。</em></li><li>bounds属性定义了一个矩形范围，表示该视图的绘制区域。</li><li>frame属性和bounds属性的区别：<ul><li>这两个属性所代表的矩形大小是一致的</li><li>frame表示的矩形的位置是相对于父视图的坐标系</li><li>bounds吊饰的矩形位于自己定义的坐标系，可以修改bounds中point来改变其子视图的的位置</li></ul></li></ul><p>改变bounds属性前:<br><img src="../img/beforeChangeBounds.png" width="150" height="250"></p><p>改变bounds属性后:<br><img src="../img/afterChangeBounds.png" width="150" height="250"></p><!-- ![改变bounds属性前](../img/beforeChangeBounds.png)![改变bounds属性后](../img/afterChangeBounds.png) --><p>看图可知，外层的view大小和位置都没有发生改变，而修改了bounds属性后，内层的view的位置发生了偏移，这是因为修改了外层view的坐标系所导致的。<br>如果将父视图的bounds属性赋给子视图的frame属性，子视图将装满父视图</p><h3 id="addSubview方法和superview属性"><a href="#addSubview方法和superview属性" class="headerlink" title="addSubview方法和superview属性"></a>addSubview方法和superview属性</h3><p>每个UIView对象都可以通过addSubview来添加子视图，并且每个UIView对象都有一个superview属性。当一个视图将另一个视图作为子视图加入，会自动创建相应的反向关联，显而易见superview属性是弱引用。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="重写dramRect方法重绘视图"><a href="#重写dramRect方法重绘视图" class="headerlink" title="重写dramRect方法重绘视图"></a>重写dramRect方法重绘视图</h3><p>ios应用启动时会开始一个运行循环（run loop）。运行循环的工作是监听事件，例如触摸。当事件发生时，运行循环会为相应的事件找到合适的处理方法。这些处理方法会调用其他方法，而这些方法又会调用更多其他方法，依此类推。只有当这些方法都执行完毕时，控制权才会再次回到运行循环。<br>　　当应用将控制权交回给运行循环时，运行循环首先会检查是否有等待重绘的视图（即在当前循环收到过setNeedsDisplay消息的视图），然后向所有等待重绘的视图发送drawRect:消息，最后视图层次结构中所有视图的图层再次组合成一幅完整的图像并绘制到屏幕上。<br>iOS做了两方面来优化来保证用户界面的流畅性—-不重绘显示内容没有改变的视图；每次事件处理周期中只发送一次drawrect消息。</p><p>为了标记视图需要重绘，必须向其发送setNeedsDisplay消息，对于SDK提供的视图对象会自动在内容发生改变的时候发送消息，而自定义的UIView子类必须后动发送消息。</p><h3 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h3><h4 id="两个尺寸的区别"><a href="#两个尺寸的区别" class="headerlink" title="两个尺寸的区别"></a>两个尺寸的区别</h4><p>UIScrollView对象适用于那些尺寸大于屏幕的视图。<br>scrollView有两个size，一个是自身的fram的size指的是这个scrollView展示在屏幕上的大小；另一个size是scrollView的contentsize，即它需要呈现的内容的大小。可以把scrollView的大小想象成是镜头的大小，而contentView的大小是需要显示的景观大小。</p><h4 id="拖动和分页"><a href="#拖动和分页" class="headerlink" title="拖动和分页"></a>拖动和分页</h4><p>当contentsize大于scrollview本身的大小时，可以通过拖拽屏幕实现展示不同的内容。<br>scrollview上的子view大小和scrollview对象的大小相同时，如果想实现拖拽时scrollview的边和子view的边对齐显示，那么就需要设置scrollView的pagingEnabled属性为YES，实现分页的效果</p><h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><p>视图控制器是UIViewController类或其子类的对象。每个视图控制器辅助管理一个视图层次结构，包括创建视图层次结构中的视图，处理用户事件，将整个层次结构添加到window中。</p><h3 id="UIViewController的View属性"><a href="#UIViewController的View属性" class="headerlink" title="UIViewController的View属性"></a>UIViewController的View属性</h3><p>view属性指向一个UIview对象，viewcontroller之所以可以管理视图层次结构就是因为view就是层次结构的根视图。当我们将view作为window的子视图时，也会加入viewcontroller对象所管理的层次结构中<br><img src="/../img/controllerHierarchy.png" alt="添加viewController之后的层次结构图"></p><h3 id="controller创建视图层次结构"><a href="#controller创建视图层次结构" class="headerlink" title="controller创建视图层次结构"></a>controller创建视图层次结构</h3><p>视图控制器不会在其被创建出来的那一刻马上创建并载入相应的视图。只有当应用需要将某个视图控制器的视图显示到屏幕上时，相应的视图控制器才会创建其视图。这种延迟加载（lazy loading）视图的做法能提高内存的使用效率。<br>视图控制器可以通过两种方式创建视图层次结构。<br>•代码方式：<strong>覆盖UIViewController中的loadView方法。</strong> 在loadview中将self.view指向要加载的子view</p><p>•文件方式：使用Interface Builder创建一个NIB文件，然后加入所需的视图层次结构，最后视图控制器会在运行时加载由该NIB文件编译而成的XIB文件。</p><p>视图控制器在刚被创建的时候，view属性被初始化为nil，当应用需要将管理器上的视图展示在屏幕上的时候，如果view属性是nil，才会调用loadview方法</p><h3 id="根视图管理器"><a href="#根视图管理器" class="headerlink" title="根视图管理器"></a>根视图管理器</h3><p>我们可以通过视图管理器来创建视图层次机构，如果要将视图管理器的视图层次结构添加到window中，需要调用window的setRootViewController方法。当某个controller成为rootcontroller，window对象会将该controller的view作为子视图加入到窗口。</p><h3 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h3><p>TBC可以保存一组视图控制器，实现在多个controller之间切换。TBC对象在屏幕底部显示一个tabbar，tab bar包括多个tab item，每一个item对应一个TBc对象所保存的视图控制器。通过点击tab item，tbc对象就会展示该标签项所对应的视图控制器的视图。<br>tabbarcontroller是uiviewcontroller的子类，也有一个view的属性，其指向一个包含两个子视图的uiview对象，分别是标签栏和当前选中的视图控制器的视图。<br><img src="/../img/tabbar%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9B%BE.png"></p><h4 id="设置标签项tab-item"><a href="#设置标签项tab-item" class="headerlink" title="设置标签项tab item"></a>设置标签项tab item</h4><p>标签栏上的每一个item都可以显示标题和图片，通过视图控制器的tabbaritem属性来设置。<br>在item对应的viewcontrol类重写initwithNibNameBundle，设置tabbarItem的title和image。<br>但是在appdelegate.m中却使用init方法来初始化viewcontroller。这是因为initwithNibNameBundle是UIViewController的指定初始化方法，当想视图控制器发送init消息的时候，会调用指定初始化方法，并传入两个nil参数。因此在appdelegate中使用init方法是可以的.</p><h4 id="视图延迟加载"><a href="#视图延迟加载" class="headerlink" title="视图延迟加载"></a>视图延迟加载</h4><p>视图延迟加载机制，会在应用启动之后，默认显示第一个视图控制器的视图，其他的等到需要展示的时候再加载。 视图控制器上的viewDidLoad方法检查视图控制器的视图是否已经加载。如果视图已经加载完之后，在切换标签项也不会再次触发viewdidload方法<br>为了实现视图延迟加载，不应该再initwithnibnamebundle中访问view或者view的子视图，将所有需要对view进行初始化的操作全都放到viewdidload中实现。</p><h4 id="访问视图"><a href="#访问视图" class="headerlink" title="访问视图"></a>访问视图</h4><p>通常需要在用户看到XIB文件中创建视图之前，对其进行初始化操作，但是根据延迟加载机制，不可能在视图控制器初始化方法中初始化视图，那么如何初始化？<br>主要有两种方法：viewDidLoad viewWillAppear</p><ol><li>viewDidLoad方法：应用启动后只调用一次</li><li>viewWillAppear方法：每次需要展示视图控制器的view的时候都会调用</li></ol><p>需求：在reminderViewController中有一个子视图dataPicker，现在是允许用户选择任意时间，如果需要设置用户只能选择当前时间之后的时间。<br>那么datapicker子视图每次展示的时候都是不一样的，需要不停的初始化，那么就需要在viewwillappear中初始化。</p><h2 id="UITableView和UITableViewController"><a href="#UITableView和UITableViewController" class="headerlink" title="UITableView和UITableViewController"></a>UITableView和UITableViewController</h2><p>iOS应用需要在界面上呈现某种列表控件，用户可以选中、删除或重排等，这些可以由UITableView完成。UITableView虽然只显示一列数据，但是没有行的限制。</p><p>根据MVC设计模式，UITableView不负责处理应用的逻辑和数据，所以需要一个和UITableView一起工作的对象：</p><ul><li>通常情况下，要通过某个视图控制对象来创建和释放UITableView对象，并负责显示或隐藏视图。</li><li>UITableView对象要有数据源才能正常工作。UITableView对象会向数据源查询要显示的行数、显示表格行所需的数据和其他所需的数据。没有数据源的UITableView对象只是空壳。凡是遵守UITableViewDataSource协议的Objective-C对象，都可以成为UITableView对象的数据源（即dataSource属性所指向的对象）。</li><li>通常情况下，要为UITableView对象设置委托对象，以便能在该对象发生特定事件时做出相应的处理。凡是遵守UITableViewDelegate协议的对象，都可以成为UITableView对象的委托对象。<br>UITableViewController可以满足以上要求：控制视图对象，数据源、委托对象。<br>UITableViewController作为UIViewController的子类也拥有view属性，其view属性指向一个UITableView对象，并且该对象由UITableViewController对象负责设置和显示。UITableViewController在创建UITableView对象之后，会将UITableView对象的delegate和datasource指向自己<br><img src="/../img/UITableViewController%E5%AF%B9%E8%B1%A1%E5%9B%BE.png"></li></ul><p>现在将UITableViewController的指定初始化方法改为init:，为此需要遵守以下两条规则：<br>　　•在新的指定初始化方法中调用父类的指定初始化方法。<br>　　•覆盖父类的指定初始化方法，调用新的指定初始化方法。</p><h1 id="触摸事件与UIResponder"><a href="#触摸事件与UIResponder" class="headerlink" title="触摸事件与UIResponder"></a>触摸事件与UIResponder</h1><h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><p>UIView是UIResponder的子类，可以处理四种不同的触摸事件</p><ul><li>touchesBegan：withEvent 手指触摸屏幕</li><li>touchesMoved：WithEvent 手指在屏幕上移动</li><li>touchesEnded：withEvent 手指离开屏幕</li><li>touchesCancelled：withEvent 在触摸操作结束前，被系统事件打断</li></ul><p>当系统检测到手指触摸屏幕的事件后，就会创建UITouch对象（一根手指的触摸事件对应一个UITouch对象）。发生触摸事件的UIView对象会收到touchesBegan:withEvent:消息，系统传入的第一个实参touches（NSSet对象）会包含所有相关的UITouch对象。<br>　　当手指在屏幕上移动时，系统会更新相应的UITouch对象，为其重新设置对应的手指在屏幕上的位置。最初发生触摸事件的那个UIView对象会收到touchesMoved:withEvent:消息，系统传入的第一个实参touches（NSSet对象）会包含所有相关的UITouch对象，而且这些UITouch对象都是最初发生触摸事件时创建的。</p><p>　　当手指离开屏幕时，系统会最后一次更新相应的UITouch对象，为其重新设置对应的手指在屏幕上的位置。接着，最初发生该触摸事件的视图会收到touchesEnded:withEvent:消息。当收到该消息的视图执行完touchesEnded:withEvent:后，系统就会释放和当前事件有关的UITouch对象<br>总结</p><ul><li>一个UITouch对象对应屏幕上的一个手指，只要手指没离开屏幕UItouch对象就不会销毁，uitouch对象会保存手指在屏幕上的位置。</li><li>当初发生触摸事件的视图会在各个阶段收到相应的触摸事件消息，即使手指已经离开了这个视图的frame区域，系统也会给这个视图发送touchesmove&#x2F;touchesended消息，即当视图发生触摸，之后的所有触摸事件都属于它</li></ul><p>当应用发生某个触摸事件后（例如触摸开始、手指移动、触摸结束），系统都会将该事件添加至一个由UIApplication单例管理的事件队列。通常情况下，很少会出现满队列的情况，所以UIApplication会立刻分发队列中的事件。分发某个触摸事件时，UIApplication会向“拥有”该事件的视图发送特定的UIResponder消息（如果读者在执行触摸操作时感觉应用的反应迟缓，就很有可能是因为应用的某个方法占用了大量CPU时间，导致队列堵塞。第14章会介绍如何查出产生这类问题的原因）。<br>　　当多根手指在同一个视图、同一个时刻执行相同的触摸动作时，UIApplication会用单个消息、一次分发所有相关的UITouch对象。UIApplication在发送特定的UIResponder消息时，会传入一个NSSet对象，该对象将包含所有相关的UITouch对象（一个UITouch对象对应一根手指）。但是，因为UIApplication对“同一个时刻”的判断很严格，所以通常情况下，哪怕一组事件都是在很短的一段时间内发生的，UIApplication也会发送多个UIResponder消息，分批发送UITouch对象。</p><h2 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h2><p>在为应用添加手势识别功能时，需要针对特定的手指创建相应的UIGestureRecognizer子类对象</p><h1 id="委托和文本输入"><a href="#委托和文本输入" class="headerlink" title="委托和文本输入"></a>委托和文本输入</h1><h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p>UIResponder是UIKit框架的一个抽象类，包括很多子类：</p><ul><li>UIView</li><li>UIViewController</li><li>UIApplication</li></ul><p>UIResponder定义了一系列方法用于接收和处理用户事件，如触摸、运动事件（晃动）、功能控制（编辑文本、播放音乐）等。<br>系统会讲触摸事件发送到被触摸的视图，其他类型的事件会由第一响应者负责处理。UIWindow有一个fisrtResponder属性指向第一响应者。当用户点击textfield，该对象会成为第一响应者，firstResponder指针会指向该对象，之后应用接收到运动事件或者功能控制事件会就发送给第一响应者。<br><img src="/../img/firstResponder.png"></p><p>当某个UITextField对象或UITextView对象成为第一响应者时，屏幕会弹出键盘。除了用户点击之外，还可以在代码中向UITextField对象发送becomeFirstResponder消息，使其成为第一响应者。相反，如果要关闭键盘，则可以向UITextField对象发送resignFirstResponder消息，且要求该对象放弃第一响应者状态。一旦第一响应者不是UITextField对象，键盘就会消失。<br>大部分的视图并不需要称为第一响应者，如UISlider对象，该对象只需要处理触摸事件，不会接受其他类型的事件，因此不用称为第一响应者。</p><h2 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h2><p>UILabel用来显示文本，UITextField可以接受用户的输入。</p><h3 id="设置textField的键盘"><a href="#设置textField的键盘" class="headerlink" title="设置textField的键盘"></a>设置textField的键盘</h3><p>UITextField对象有一系列属性用来设置弹出的键盘。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">textFiled.placeholder</span> = @<span class="hljs-string">&quot;Hypnotize me.&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attr">textFiled.returnKeyType</span> = UIReturnKeyDone<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>设置编辑栏的占位符文本和键盘的换行符的文本</p><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>在之前使用过Target-Action设计模式，是UIKit中常用的设计模式。该设计模式的工作方式：当某个特定事件发生时（如按下按钮），发生事件的一方会向特定的目标对象发送一个预设好的动作消息。但是这种设计模式的缺陷在于，时间和目标时一对一的。比如说按下按钮，目标就是处理点击事件。如果是比较复杂的事件就不能用这种模式处理。<br>UITextField对象具有一个委托属性delegate，这个委托是UITextFieldDelegate类型的。以下是委托方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">UITextFieldDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br><span class="hljs-keyword">@optional</span><br><br>- (<span class="hljs-type">BOOL</span>)textFieldShouldBeginEditing:(<span class="hljs-built_in">UITextField</span> *)textField;        <span class="hljs-comment">// return NO to disallow editing.</span><br>- (<span class="hljs-type">void</span>)textFieldDidBeginEditing:(<span class="hljs-built_in">UITextField</span> *)textField;           <span class="hljs-comment">// became first responder</span><br>- (<span class="hljs-type">BOOL</span>)textFieldShouldEndEditing:(<span class="hljs-built_in">UITextField</span> *)textField;          <span class="hljs-comment">// return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end</span><br>- (<span class="hljs-type">void</span>)textFieldDidEndEditing:(<span class="hljs-built_in">UITextField</span> *)textField;             <span class="hljs-comment">// may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called</span><br>- (<span class="hljs-type">void</span>)textFieldDidEndEditing:(<span class="hljs-built_in">UITextField</span> *)textField reason:(<span class="hljs-built_in">UITextFieldDidEndEditingReason</span>)reason API_AVAILABLE(ios(<span class="hljs-number">10.0</span>)); <span class="hljs-comment">// if implemented, called in place of textFieldDidEndEditing:</span><br><br>- (<span class="hljs-type">BOOL</span>)textField:(<span class="hljs-built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="hljs-built_in">NSRange</span>)range replacementString:(<span class="hljs-built_in">NSString</span> *)string;   <span class="hljs-comment">// return NO to not change text</span><br><br>- (<span class="hljs-type">void</span>)textFieldDidChangeSelection:(<span class="hljs-built_in">UITextField</span> *)textField API_AVAILABLE(ios(<span class="hljs-number">13.0</span>), tvos(<span class="hljs-number">13.0</span>));<br><br>- (<span class="hljs-type">BOOL</span>)textFieldShouldClear:(<span class="hljs-built_in">UITextField</span> *)textField;               <span class="hljs-comment">// called when clear button pressed. return NO to ignore (no notifications)</span><br>- (<span class="hljs-type">BOOL</span>)textFieldShouldReturn:(<span class="hljs-built_in">UITextField</span> *)textField;              <span class="hljs-comment">// called when &#x27;return&#x27; key pressed. return NO to ignore.</span><br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p><em>NOTE：在委托方法中通常将对象自身作为第一个参数，如果视图控制器有多个TextField对象，她们的委托都是该视图控制器，那么就需要根据textFielf参数获得相应的textField对象并执行不同的操作。</em></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote><p>被委托对象：拥有一个delegate属性，以及有协议，协议中声明了一些方法<br>委托对象：委托对象需要根据协议实现相应的方法。并在头文件或者类扩展@interface指令后面 将遵守的协议写在尖括号里。<br>textField.delegate &#x3D; self;<br>textField对象就是被委托对象，self，即这里的视图控制器就是委托对象<br>textFielf对象委托视图控制器来完成一些callback<br>支持委托的对象，都有一个协议，声明了可以向该对象的委托对象发送的消息，委托对象需要根据需求实现相应的方法。<br>声明协议的语法是，使用@protocol指令 后面跟着协议名称 <NSObject><br>尖括号内包括了NSObject协议的全部方法。如何声明协议的新增方法，@end结束<br><em>NOTE：协议不是类，只是一组方法声明，协议本身不实现方法，只有委托对象才会实现协议里的方法，相当于市java中的接口的概念</em><br>协议中声明的方法可分为必须实现的@required和可选的@optional<br>被委托对象在调用可选方法之前，会像委托对象发送一个<code>respondsToSelector:</code>消息，判断委托对象是否实现了指定的方法。<br>需要注意的是，几乎所有的委托都是弱引用属性，这是为了避免对象和委托对象之间产生强引用循环。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">weak</span>)   <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">UITextFieldDelegate</span>&gt; delegate;             <span class="hljs-comment">// default is nil. weak reference</span><br><br></code></pre></td></tr></table></figure><p><img src="/../img/weakDelegate.png"></p><h2 id="运动效果"><a href="#运动效果" class="headerlink" title="运动效果"></a>运动效果</h2><blockquote><p>ios设备内嵌了许多功能强大的传感器，例如加速传感器，磁场传感器和三轴陀螺仪等。应用可以通过这些感应器了解设备的速度、方向和角度，并实现有用的功能。例如，应用可以根据设备的方向自动将界面调整为横排模式或竖排模式。<br>应用可以通过UIInterpolatingMotionEffect类实现效果，设置方向，键路径，相对值，在添加到视图上。</p></blockquote><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h1 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h1><h2 id="键值编码"><a href="#键值编码" class="headerlink" title="键值编码"></a>键值编码</h2><p>当NIB文件被加载之后，outlet便利是通过KVC的方式来设置的。键值编码valueForKey： 和 setValue：forKey方法来实现通过属性的名称来存取属性的值。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">id currentFido = [selectedObject valueForKey:@<span class="hljs-string">&quot;fido&quot;</span>];<br>[selectedObject setValue:value forKey:@<span class="hljs-string">&quot;fido&quot;</span>];<br></code></pre></td></tr></table></figure><p>NIB文件在加载时会使用setValue:forKey:设置插座变量。例如，如果需要为某个对象设置一个名为rex的插座变量，那么该对象必须定义了setRex:方法或者具有_rex实例变量（或rex实例变量），否则在加载NIB文件时会抛出异常</p><h2 id="Retina显示屏"><a href="#Retina显示屏" class="headerlink" title="Retina显示屏"></a>Retina显示屏</h2><h2 id="main和UIApplication"><a href="#main和UIApplication" class="headerlink" title="main和UIApplication"></a>main和UIApplication</h2><p>在OC的main函数里的UIApplicationMain函数会创建一个UIApplication对象。每一个iOS应用只有一个UIApplication对象，该对象的作用是维护运行循环。一旦程序创建了该对象之后，运行循环就会一直循环下去，main（）的执行也会因此阻塞。<br>此外，UIApplicationMain函数还会创建某个指定类的对象，并将其设置为UIApplication对象的delegate。该对象的类是由UIApplicationMain函数的最后一个实参指定的，该实参的类型是NSString对象，代表的是某个类的类名。所以在以上这段代码中，UIApplicationMain会创建一个BNRAppDelegate对象，并将其设置为UIApplication对象的delegate。<br>在应用启动运行循环并开始接收事件前，UIApplication对象会向其委托发送一个特定的消息，使应用能有机会完成相应的初始化工作。这个消息的名称是application:didFinishLaunchingWithOptions:</p><h2 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h2><p>许多继承UIResponder的子类既不是视图对象，也无法触摸显示，这些子类无法直接发送触摸事件，但是可以响应对象链接接受事件。<br>UIResponder对象拥有一个名为nextResponder的指针，相关的UIResponder对象可以通过该指针组成一个响应对象链。当UIView对象属于某个UIViewController对象时，其nextResponder指针就会指向包含该视图的UIViewController对象。当UIView对象不属于任何UIViewController对象时，其nextResponder指针就会指向该视图的父视图。UIViewController对象的nextResponder通常会指向其视图的父视图。最顶层的父视图是UIWindow对象，而UIWindow对象的nextResponder指向的是UIApplication单例。<br><img src="/../img/%E5%93%8D%E5%BA%94%E9%93%BE.png"><br>如果UIResponder没有处理传给它的事件，该对象会讲未处理的次奥西转发给自己的nextResponder。这就是touchedbegin方法默认的实现方式。只要没有为某个UIresponder对象覆盖该方法，那么该对象nextRedponder会尝试处理，最终传递给UIapplication，如果其也无法处理就会丢弃。</p><h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p>UIControl是UIButton UISlider的父类，一般对于UIcontrol对象设置action-target方法来处理逻辑。<br>对于UIControl对象，每个可能触发的控件事件都有一个对应的常量。以UIButton对象为例，该对象的常用控件事件是UIControlEventTouchUpInside。如果某个目标对象是针对UIControlEventTouchUpInside注册的，那么只有当用户触摸了这个UIControl对象，并且手指是在该对象的frame区域内离开屏幕时，目标对象才会收到指定的动作消息。因此，可以将控件事件UIControlEventTouchUpInside视为按下操作。<br>为实现，无论用户手指是在frame内还是外离开屏幕都会触发某个事件的逻辑</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[button addTraget:<span class="hljs-keyword">self</span><br>           action:<span class="hljs-keyword">@selector</span>(xxx)<br> forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span><br>      | <span class="hljs-built_in">UIControlEventTouchUpOutside</span> ];<br></code></pre></td></tr></table></figure><p>那么UIControl对象是如何将这些动作消息发送给相应的目标对象的？在上面这段touchesEnded:withEvent:方法的末尾，UIControl对象会向自己发送sendActions- ForControlEvents:消息。该消息会遍历UIControl对象的所有目标-动作对，根据传入的控件事件类型进行查找，然后向匹配的目标对象发送对应的动作消息。<br>　　但是，UIControl对象绝对不是直接向目标对象发送消息，而是要通过UIApplication转发。为什么UIControl对象不能直接向目标对象发送动作消息？这是因为在UIControl对象所拥有的目标-动作对中，目标对象可以是nil。UIApplication在转发源自UIControl对象的消息时，会先判断目标对象是不是nil。如果是nil，UIApplication就会先找出UIWindow对象的第一响应对象，然后向第一响应对象发送相应的动作消息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS 语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
