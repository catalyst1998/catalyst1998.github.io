<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NSURLSession详解</title>
    <link href="/2022/05/19/NSURLSession%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/05/19/NSURLSession%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="URL-Loading-System"><a href="#URL-Loading-System" class="headerlink" title="URL Loading System"></a>URL Loading System</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><img src="/./../img/URLSession/overview.png" alt="overview"></p><p>URL 加载系统（URL Loading System）使用标准协议（如 https）或自定义协议提供对 URL 标识资源进行访问。URL Loading System 是异步执行的，这样 app 可以保持响应，并在 response 到达时处理数据或错误。<br>使用URLSession实例创建一个或多个URLSessionTask实例，URLSessionTask实例可以拉取数据并将数据返回到 app、下载文件，或将文件、数据上传到远程服务器。使用URLSessionConfiguration对象配置URLSession的实例 session（会话），URLSessionConfiguration对象可以配置 caches、cookies 策略，以及是否允许使用数据流量等。<br>可以使用一个 session 重复创建 task。例如，浏览器为正常浏览和无痕模式使用单独的 session，无痕浏览不会保存数据到磁盘。</p><h2 id="2-URLSessionConfiguration"><a href="#2-URLSessionConfiguration" class="headerlink" title="2 URLSessionConfiguration"></a>2 URLSessionConfiguration</h2><p>URLSessionConfiguration相当于是管家，负责为seesion配置在网络交互过程中的各种属性。<br>URLSessionConfiguration 允许通过各种属性来设置configuration，包括setting cookie policies、setting security policies、setting caching policies、Setting HTTP Policy and Proxy Properties、Supporting Background Transfers等</p><p><img src="/./../img/URLSession/%E5%B1%9E%E6%80%A7.png" alt="configuration属性"></p><p>从上图上可以看到常用的属性：<code>allowsCellularAccess</code>–是否允许访问蜂窝网, <code>HTTPMaximumConnectionsPerHost</code>–最大连接数, <code>requestCachePolicy</code>–cache策略等</p><p>apple提供了三种类型的configuration</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs objective-c">@property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration;<br>@property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration;<br>+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));<br></code></pre></td></tr></table></figure><p>官方对这几种类型的configuration的解释：</p><blockquote><ul><li>The singleton shared session (which has no configuration object) is for basic requests. It’s not as customizable as sessions that you create, but it serves as a good starting point if you have very limited requirements. You access this session by calling the shared class method. See that method’s discussion for more information about its limitations.</li><li>Default sessions behave much like the shared session (unless you customize them further), but let you obtain data incrementally using a delegate. You can create a default session configuration by calling the default method on the URLSessionConfiguration class.</li><li>Ephemeral sessions are similar to default sessions, but they don’t write caches, cookies, or credentials to disk. You can create an ephemeral session configuration by calling the ephemeral method on the URLSessionConfiguration class.</li><li>Background sessions let you perform uploads and downloads of content in the background while your app isn’t running. You can create a background session configuration by calling the backgroundSessionConfiguration(_:) method on the URLSessionConfiguration class.</li></ul></blockquote><p>对于shared session和default其实比较相似，只不过default可以自定义一些参数。default，it uses the disk-persisted global cache,credential and cookie storage objects. Ephemeral, store all data in memory.<br>其中<code>backgroundSessionConfiguration:</code>的<code>identifier</code>参数在整个app中必须是唯一的，如果出现重复其后果是严重的！<br>通过该identifier，我们可以创建新的background session，用于获取与其绑定的download or upload response。</p><h2 id="3-URLSessionTask"><a href="#3-URLSessionTask" class="headerlink" title="3 URLSessionTask"></a>3 URLSessionTask</h2><blockquote><p>NSURLSessionTask - a cancelable object that refers to the lifetime of processing a given request.</p></blockquote><p>URLSessionTask是真正干活的人，但他并没有初始方法，必须归属于seesion。<br>URLSessionTask是URL会话任务的抽象类，有四个具体的子类<br><img src="/./../img/URLSession/task.png" alt="3"></p><ul><li><p><code>URLSessionDataTask</code>：Use this task for GET requests to retrieve data from servers to memory.<br>使用 <code>dataTask(with:)</code>方法创建<code>URLSessionDataTask</code>实例，datatask 用于请求资源(如：JSON、XML格式的数据），将服务器的响应作为一个或多个<code>NSData</code>对象返回到内存中。Default、ephemeral、shared session 支持<code>URLSessionDataTask</code>，<code>backgroundsession</code> 不支持<code>URLSessionDataTask</code>。</p></li><li><p><code>URLSessionUploadTask</code>：Use this task to upload a file from disk to a web service via a POST or PUT method.<br>使用 <code>uploadTask(with:from:)</code>方法创建<code>URLSessionUploadTask</code>实例，用于通过HTTP协议向服务器上传数据或文件,URLSessionUploadTask继承自URLSessionDataTask。使用URLSessionUploadTask 可以很方便为 request 提供 body（例如，POST 或 PUT），还可以在收到 response 前上传数据。此外，upload task 支持后台会话。<br>在 iOS 中，为 background session 创建 upload task 时，系统会将文件复制到临时目录，然后从临时目录上传。</p></li><li><p>URLSessionDownloadTask：Use this task to download a file from a remote service to a temporary file location.<br>使用<code>downloadTask(with:)</code>方法创建URLSessionDownloadTask 实例，download task 将资源直接下载到磁盘上的文件。Download task 支持任何类型的会话。download task可以pause、resume</p></li><li><p>URLSessionStreamTask：使用streamTask(withHostName:port:)或streamTask(with:)方法创建URLSessionStreamTask实例。流任务（stream task）从主机、端口或网络服务建立 TCP&#x2F;IP连接。</p></li></ul><p><em>NOTE，在创建完任务之后，需要调用resume 方法才会启动任务。在任务完成或失败前，session 会强引用 task。如果没有特别用途，不需要维护对任务的引用。</em></p><h2 id="4-URLSession"><a href="#4-URLSession" class="headerlink" title="4 URLSession"></a>4 URLSession</h2><h3 id="4-1-URLSession-overview"><a href="#4-1-URLSession-overview" class="headerlink" title="4.1 URLSession overview"></a>4.1 URLSession overview</h3><p>URLSession is both a class and a suite of classes for handling HTTP- and HTTPS-based requests.<br>URLSession是整个体系中的领导。<br><img src="/./../img/URLSession/2.png" alt="2"></p><p><em>NOTE：一个session可以创建多个task，并且session中的所有的task共享configuration</em></p><h3 id="4-2-Create-URLSession"><a href="#4-2-Create-URLSession" class="headerlink" title="4.2 Create URLSession"></a>4.2 Create URLSession</h3><p><a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc#topics">官方文档</a></p><blockquote><p>Configuration options for an NSURLSession.  When a session is created, a copy of the configuration object is made - you cannot modify the configuration of a session after it has been created.</p></blockquote><p>可以通过单例sharedSession来使用session，也可以通过URLSessionConfiguration来创建configuration，配置session。</p><p><strong>创建NSURLSession的三个类方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs obejctive-c">// 使用default configuration并且该session中的task必须提供completionHandler<br>+ (NSURLSession *)sharedSession;<br><br>// 该session中的task必须提供completionHandler<br>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;<br><br>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id&lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(NSOperationQueue *)queue;<br></code></pre></td></tr></table></figure><ul><li>NOTE：</li></ul><ul><li>在创建session的时候会拷贝configuration，并且在创建session之后，不允许修改configuration。</li><li>NSURLSession对delegate是strong reference，直到我们显式地调用 invalidateAndCancel 或 resetWithCompletionHandler:方法。因此，在使用过程中要注意retain cycle。*</li></ul><h2 id="5-URLSessionDelegate"><a href="#5-URLSessionDelegate" class="headerlink" title="5 URLSessionDelegate"></a>5 URLSessionDelegate</h2><blockquote><p>NSURLSessionDelegate specifies the methods that a session delegate may respond to.  There are both session specific messages (for example, connection based auth) as well as task based messages.</p></blockquote><p><img src="/./../img/URLSession/delegate.png" alt="3"></p><p>URLSessionDelegate定义了URLSession实例调用delegate处理session事件的方法。除实现URLSessionDelegate协议内方法，大部分 delegate 还需要实现URLSessionTaskDelegate、URLSessionDataDelegate、URLSessionDownloadDelegate中的一个或多个协议，以便处理 task 级事件，<br>URLSessionDelegate 有三个optional方法</p><ol><li><code>- (void)URLSession: didBecomeInvalidWithError: </code>该方法通知session是否失效<blockquote><p>The last message a session receives.  A session will only become invalid because of a systemic error or when it has been explicitly invalidated, in which case the error parameter will be nil.</p></blockquote></li></ol><p>如果通过调用finishTasksAndInvalidate()方法使会话无效，会话会在最后一个 task 完成或失败后调用该方法<br>如果通过调用invalidateAndCancel()方法使会话无效，会话立即调用该方法。</p><blockquote><p>If implemented, when a connection level authentication challenge has occurred, this delegate will be given the opportunity to provide authentication credentials to the underlying connection. Some types of authentication will apply to more than one request on a given connection to a server (SSL Server Trust challenges). If this delegate message is not implemented, the behavior will be to use the default handling, which may involve user interaction.</p></blockquote><p>2.<code> - (void)URLSession: didReceiveChallenge: completionHandler:</code> 该方法主要是处理远程服务器的会话级身份验证请求。遇到以下两种情况时会调用该方法：</p><ol><li>远程服务器请求客户端证书，或 Windows NT LAN Manager（NTLM）认证时会调用该方法以提供适当的凭据。</li><li>当 session 与使用 SSL 或 TLS 的远程服务器首次建立连接时，使用该方法验证服务器的证书链。<br>如果未实现该方法，session 会调用URLSessionTaskDelegate协议中urlSession(_:task:didReceive:completionHandler:)方法，采用 task 级认证。</li></ol><blockquote><p>If an application has received an application: handleEventsForBackgroundURLSession: completionHandler:  message, the session delegate will receive this message to indicate that all messages previously enqueued for this session have been delivered.  At this time it is safe to invoke the previously stored completion handler, or to begin any internal updates that will result in invoking the completion handler.</p></blockquote><ol start="3"><li><code>- (void)URLSessionDidFinishEventsForBackgroundURLSession:</code></li></ol><h2 id="6-URLSessionTaskDelegate"><a href="#6-URLSessionTaskDelegate" class="headerlink" title="6 URLSessionTaskDelegate"></a>6 URLSessionTaskDelegate</h2><p>URLSessionTaskDelegate协议定义了 URL Session 实例调用 delegate 处理 task 级事件的方法。URLSessionTaskDelegate继承自URLSessionDelegate。</p><h3 id="6-1-处理task生命周期"><a href="#6-1-处理task生命周期" class="headerlink" title="6.1 处理task生命周期"></a>6.1 处理task生命周期</h3><p>当任务完成是会调用<code>- (void)URLSession: task: didCompleteWithError:</code>方法。如果发生错误，error参数会包含失败的原因。</p><h3 id="6-2-处理重定向"><a href="#6-2-处理重定向" class="headerlink" title="6.2 处理重定向"></a>6.2 处理重定向</h3><p>当远程服务器请求http重定向时，会调用<code>- (void)URLSession:task:willPerformHTTPRedirection:newRequest: completionHandler:</code>方法。<br>在该方法内必须调用 completion handler。如果允许重定向，为 completion handler 传入 request 参数；如果需要修改重定向，传入修改后的 request 对象；如果禁止重定向，则参数传 nil，此时得到的 response 就是重定向。</p><h3 id="6-3-处理upload-task"><a href="#6-3-处理upload-task" class="headerlink" title="6.3 处理upload task"></a>6.3 处理upload task</h3><p>上传文件时会定期调用<code>- (void)URLSession: task: didSendBodyData: totalBytesSent: totalBytesExpectedToSend:</code>方法，以显示上传进度。</p><h3 id="6-4-采集数据"><a href="#6-4-采集数据" class="headerlink" title="6.4 采集数据"></a>6.4 采集数据</h3><p>调用 <code>- (void)URLSession: task: didFinishCollectingMetrics:</code>方法，收集task完成的信息。其中materics参数封装了task的指标</p><p><code>URLSessionTaskMetrics</code>类包含以下三个属性：</p><ul><li><code>taskInterval：</code>任务发起至任务完成的时间。</li><li><code>redirectCount：</code>任务执行过程中重定向次数。</li><li><code>transactionMetrics</code>：数组内元素为任务执行期间每个 request-response 事务度量标准。元素类型为URLSessionTaskTransactionMetrics。</li></ul><p><code>URLSessionTaskTransactionMetrics</code>对象封装执行会话任务期间收集的性能指标。每个<code>URLSessionTaskTransactionMetrics</code>对象包含了一个 request 和 response 属性，对应于 task 的 request 和 response。其也包含时间指标（temporal metrics），以fetchStartDate开始，以responseEndDate结束，以及其他特性，例如：networkProtocolName和resourceFetchType</p><p><img src="/./../img/URLSession/4.png" alt="4"></p><p>可以使用该方法查看请求各阶段所占用的时间，优化性能。</p><h2 id="7-URLSessionDataDelegate"><a href="#7-URLSessionDataDelegate" class="headerlink" title="7 URLSessionDataDelegate"></a>7 URLSessionDataDelegate</h2><p><code>URLSessionDataDelegate</code>协议定义了 URL session 实例处理 data task、upload task 任务级事件方法。URLSessionDataDelegate继承自URLSessionTaskDelegate协议。</p><p>Data task 接收到服务器的初始回复（header）时，会调用<code>- (void)URLSession: dataTask：didReceiveResponse:  completionHandler:</code>方法<br>只有在接收到 response header 后需要取消任务，或将任务转变为 download task 时才需要实现该方法。未实现该方法时，默认允许继续传输数据。<br>可以在completionHandler中传入URLSession.ResponseDisposition常量。</p><ul><li><code>URLSession.ResponseDisposition.allow：</code>任务继续作为 data task 执行。</li><li><code>URLSession.ResponseDisposition.cancel：</code>取消任务。</li><li><code>URLSession.ResponseDisposition.becomeDownload：</code>调用<code>urlSession(_:dataTask:didBecome:)</code>方法，创建一个 download task 取代当前的 data task。</li></ul><p>Data task 接收到数据时会调用urlSession(_:dataTask:didReceive:)方法。该方法可能被调用多次，每次调用提供上次调用后的数据，你的 app 负责将所需数据拼接起来。</p><p>Data task 或 upload task 在接收完所有数据后会调用urlSession(_:dataTask:willCacheResponse:completionHandler:)方法，以决定是否将响应存储到缓存中。如果没有实现该方法，则根据会话的 configuration 决定是否保存。该方法的主要用途在于阻止指定 URL 缓存响应，或修改缓存的 userInfo 字典。实现该方法后必须调用 completionHandler，传入 proposed response 或修改后的 response 缓存数据，或nil禁止缓存 response。<br>只有在URLProtocol协议允许缓存 response 时，才会调用该方法。下面所有条件均成立时才会缓存响应：</p><ul><li>请求是 HTTP 或 HTTPS 类型，也可以是支持缓存的自定义网络协议。</li><li>请求成功，即状态码在200至299区间。</li><li>response 来自服务器，而非缓存。</li><li>会话配置允许缓存。</li><li>URLRequest缓存策略允许缓存。</li><li>服务器响应中与缓存相关的 header 允许缓存。</li><li>响应大小足够小，能够进行缓存。例如，如果提供磁盘缓存，则响应不得大于磁盘缓存大小的5%。</li></ul><h2 id="8-CompletionHandler-还是-delegat"><a href="#8-CompletionHandler-还是-delegat" class="headerlink" title="8 CompletionHandler 还是 delegat"></a>8 CompletionHandler 还是 delegat</h2><h3 id="8-1-如何选择"><a href="#8-1-如何选择" class="headerlink" title="8.1 如何选择"></a>8.1 如何选择</h3><p>前文说到的用于创建URLSeeion的类方法中，一个需要delegate，两个需要completionHandler。那么什么时候用delegate什么时候用completionHandler？</p><p>以下情况需要提供completionHandler，其余情况可以交给delegate处理</p><ul><li>当App处于background、suspended以及out-of-process状态时，需要由background sessions上传或下载数据；</li><li>自定义网络鉴权；</li><li>自定义SSL验证；</li><li>由服务器返回的MIME type决定一个网络传输是下载到磁盘还是直接display；</li><li>通过body stream上传数据；</li><li>自定义cache；</li><li>自定义HTTP redirects；</li></ul><h3 id="8-2-区别"><a href="#8-2-区别" class="headerlink" title="8.2 区别"></a>8.2 区别</h3><p><img src="/./../img/URLSession/5.png" alt="5"><br>完成处理程序需要处理以下三件事：</p><ol><li>验证 error 参数是否为 nil。如果不为 nil，则传输时发生错误。此时应处理错误并退出。</li><li>检查响应的状态码（status code）是否指示成功，以及 MIME 类型是否为预期值。如果不符合，处理服务器错误并退出。</li><li>根据需要使用返回的 data。</li></ol><p><img src="/./../img/URLSession/6.png" alt="6"></p><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h2><p>使用NSURLSession加载数据流程：<br>0. 创建configuration</p><ol><li>创建session</li><li>通过url和参数创建task</li><li>调用resume开始task</li><li>在handler、delegate中处理回调</li></ol><p>参考：</p><ul><li><a href="https://www.youtube.com/watch?v=zvfViYmETuc&t=8s">YouTube视频</a></li><li><a href="https://github.com/pro648/tips/wiki/URLSession%e8%af%a6%e8%a7%a3">URLSession详解 · pro648&#x2F;tips Wiki</a></li><li><a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started">URLSession Tutorial: Getting Started</a></li><li><a href="http://zxfcumtcs.github.io/2014/08/02/NSUrlSession/">NSURLSession——网络框架新生代</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS文件系统</title>
    <link href="/2022/05/13/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/05/13/iOS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS文件系统"><a href="#iOS文件系统" class="headerlink" title="iOS文件系统"></a>iOS文件系统</h1><h2 id="1-iOS系统的沙盒机制"><a href="#1-iOS系统的沙盒机制" class="headerlink" title="1.iOS系统的沙盒机制"></a>1.iOS系统的沙盒机制</h2><p>在iOS系统中，应用程序只能在自己创建的文件系统中读取文件，这种独立、封闭、安全的空间称为沙盒，<br>沙盒机制是iOS系统的一种安全手段。</p><p>沙盒模型下有四个主要的目录：<br><img src="/../img/%E6%B2%99%E7%9B%92.png"></p><ul><li>App：是应用程序的程序包目录，包括应用程序的二进制文件、资源文件和plist等，由于应用程序必须经过签名，所以在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动，故该目录为只读</li><li>Documents：存放需要持久的数据，该目录会被iTunes&#x2F;iCloud备份<ul><li>特点：支持用户数据共享</li></ul></li><li>Tmp：存放临时文件的目录，当应用程序退出之后，会自动清除</li><li>Library：<ul><li>Caches：存放应用程序运行时生成的数据，即缓存，比如音乐缓存，图片缓存等，用户使用过程中的缓存都可以保存在这个目录中，可用于保存可再生文件，应用程序也需要负责删除这些文件，不会自动清除也不会参与备份。</li><li>Preferecnces：存放应用程序的偏好设置，使用NSUserDefault存取，该目录会被iTunes&#x2F;iCloud备份。</li><li>注意，并不是说Library下只有这两个子文件夹，后续会生成各种子文件夹如Cookies等</li><li>特点：可以自定义子文件夹</li></ul></li></ul><blockquote><p>真实目录结构是 在&#x2F;data&#x2F;Containers 文件下有两个子文件夹，分别为Bundle、Data。其中，</p><ul><li>Bundle存放着程序的plist和 xxx.app</li><li>Data下有Documents、Library、SystemData、tmp子文件夹<br><img src="/../img/bundle.png"><br><img src="/../img/data.png"></li></ul></blockquote><h2 id="2-获取文件地址"><a href="#2-获取文件地址" class="headerlink" title="2.获取文件地址"></a>2.获取文件地址</h2><p>主要是使用NSPathUtilities</p><figure class="highlight objectivec"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 获取沙盒主目录路径</span><br><span class="hljs-built_in">NSString</span> *homeDir = <span class="hljs-built_in">NSHomeDirectory</span>(); <br><br><span class="hljs-comment">// 获取Documents目录路径</span><br><span class="hljs-built_in">NSString</span> *docDir = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSDocumentDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) firstObject];<br><br><span class="hljs-comment">// 获取Library的目录路径</span><br><span class="hljs-built_in">NSString</span> *libDir = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSLibraryDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) lastObject];<br><br><span class="hljs-comment">// 获取Caches目录路径</span><br><span class="hljs-built_in">NSString</span> *cachesDir = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSCachesDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) firstObject];<br><br><span class="hljs-comment">// 获取tmp目录路径</span><br><span class="hljs-built_in">NSString</span> *tmpDir =  <span class="hljs-built_in">NSTemporaryDirectory</span>();<br><br><span class="hljs-comment">//应用程序程序包的路径</span><br>[[<span class="hljs-built_in">NSBundle</span> mainBundle] bundlePath]<br><br></code></pre></td></tr></table></figure><h2 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h2><p>主要是用NSFileHandler和NSFileManager</p><h3 id="NSFileHandler"><a href="#NSFileHandler" class="headerlink" title="NSFileHandler"></a>NSFileHandler</h3><p>主要负责对文件内容进行操作</p><ul><li>读取文件&amp;写文件</li><li>读取指定长度的*在指定位置追加&#x2F;截断</li><li>截断&#x2F;刷新</li><li>常用鱼追加数据</li></ul><p>创建</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm">+ (nullable instance<span class="hljs-keyword">type</span>)fileHandleForReadingAtPath:(<span class="hljs-type">NSString</span> *)path;<br><br>+ (nullable instance<span class="hljs-keyword">type</span>)fileHandleForWritingAtPath:(<span class="hljs-type">NSString</span> *)path;<br><br>+ (nullable instance<span class="hljs-keyword">type</span>)fileHandleForUpdatingAtPath:(<span class="hljs-type">NSString</span> *)path;<br></code></pre></td></tr></table></figure><p>读&amp;写</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSData</span> *)readDataToEndOfFile;<br><br>- (<span class="hljs-built_in">NSData</span> *)readDataOfLength:(<span class="hljs-built_in">NSUInteger</span>)length;<br><br>- (<span class="hljs-type">void</span>)writeData:(<span class="hljs-built_in">NSData</span> *)data;<br><br>- (<span class="hljs-type">void</span>)seekToFileOffset:(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)offset<br><br></code></pre></td></tr></table></figure><h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><p>通过NSURL或者NSString作为Path,主要是对文件进行管理</p><ul><li>单例，提供app内文件&amp;文件夹的管理</li><li>创建、删除、查询、移动、复制文件等</li><li>读取文件内容和属性</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)createDirectoryAtPath:(<span class="hljs-built_in">NSString</span> *)path withIntermediateDirectories:(<span class="hljs-type">BOOL</span>)createIntermediates attributes:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSFileAttributeKey</span>, <span class="hljs-type">id</span>&gt; *)attributes error:(<span class="hljs-built_in">NSError</span> **)error;<br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSString</span> *&gt; *)contentsOfDirectoryAtPath:(<span class="hljs-built_in">NSString</span> *)path error:(<span class="hljs-built_in">NSError</span> **)error;<br><br>- (<span class="hljs-type">BOOL</span>)fileExistsAtPath:(<span class="hljs-built_in">NSString</span> *)path;<br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSData</span> *)contentsAtPath:(<span class="hljs-built_in">NSString</span> *)path;<br><br>- (<span class="hljs-type">BOOL</span>)removeItemAtPath:(<span class="hljs-built_in">NSString</span> *)path error:(<span class="hljs-built_in">NSError</span> **)error;<br></code></pre></td></tr></table></figure><h4 id="NSFileManagerDelegate"><a href="#NSFileManagerDelegate" class="headerlink" title="NSFileManagerDelegate"></a>NSFileManagerDelegate</h4><p>提供移动、复制、删除等操作的具体自定义实现 </p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS 文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS编程</title>
    <link href="/2022/05/06/iOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/06/iOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Objective-C-基础语法"><a href="#Objective-C-基础语法" class="headerlink" title="Objective-C 基础语法"></a>Objective-C 基础语法</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是iOS开发者必须遵守的一个设计模式</p><ul><li>模型Model：负责存储数据，与用户界面无关</li><li>视图View：负责显示界面，与模型无关</li><li>控制器Controller：负责确保视图对象和模型对象的数据一致性</li></ul><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><blockquote><p>当某个对象初始化完成了，就可以向其发送消息，消息需要包括三个部分</p><ul><li>receiver接收方：是一个指针，指向执行方法的对象</li><li>selector选择器：需要执行方法的方法名</li><li>arguments实参：以变量形式传递给方法的数值</li></ul></blockquote><p><code>[person sayHi:someName];</code> 向Person类的实例对象person发送sayHi消息，该消息会触发person的sayHi方法，并传入参数someName<br><code>[person sayHi:someName       withGift:someGift];</code>  这条消息接受多个实参，每个实参都会和选择其中的对应的标签配对，每个标签以冒号结束。</p><p><strong>NOTE：所有的标签合在一起才构成一个selector，并且即使有多个标签，但是仍然只触发了一个方法，即sayHi：withGift：方法</strong></p><p>在OC中，方法的唯一性只取决于方法名，即使参数类型返回值类型不同，一个类也不允许出现两个名称相同的方法。<br><em>NOTE：在OC中，需要注意方法和消息的区别，方法指的是一块可执行的代码，消息指的是要求类或者实例对象执行某个方法的动作。</em></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在OC中数组包含的对象不是对象本身，而是指向对象的指针，即数组保存对象的内存地址。<br>NSMutableArray是NSArray的子类，可以动态的添加删除元素。<br>使用<code>addObject:</code> 尾插法添加元素 <code>insertObject:atIndex:</code> 在执行位置加入元素<br><code>objectAtIndex: </code>访问执行位置的元素    <code>count</code> 返回数组元素的个数<br>快速枚举（fast enumeration）</p><figure class="highlight scss"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(NSString *item in array)&#123;<br>    <span class="hljs-built_in">NSL</span>(xxx);<br>&#125;   <br></code></pre></td></tr></table></figure><p><strong>NOTE：需要注意的是，使用fast enumreation的时候，不能在循环体内添加或者删除元素，会报并发修改异常</strong></p><h4 id="深入学习数组"><a href="#深入学习数组" class="headerlink" title="深入学习数组"></a>深入学习数组</h4><p>OC中数组可以存储不同类型的对象，因为存的是对象的指针（指针大小一致），不像其他强类型语言只能保存一种类型的对象。并且因为数组存的是对象的指针，因此基本类型不能存，需要包装成<code>NSNumber</code>、<code>NSValue</code>、<code>NSData</code>等<br>需要注意数组不能存nil，需要将nil转成NSNull对象<br>访问数组对象的时候，可以使用下标语法<br><code> [items objectAtIndex:3] == items[3]</code> </p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CItem</span> : <span class="hljs-title">NSObject</span></span><br>&#123;<br>    <span class="hljs-built_in">NSString</span> *_itemNAme;<br>    <span class="hljs-built_in">NSString</span> *_serialNumber;<br>    <span class="hljs-type">int</span> _valueInDollars;<br>    <span class="hljs-built_in">NSDate</span> *_dateCreated;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对CItem类来说，每个实例对象包含了一个int类型的数值，和是哪个指向对象的指针。如_itemName指向一个NSString对象，该对象的内容是“RED SOFA”字符串，需要注意的是，_itemName存的是该字符串的地址，而不是字符串本身.</p><h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><p>在OC中，存方法的命名规则：set+要修改的实例变量的变量名，如setItemName；取方法的命名规则：实例变量的变量名，如itemName。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[item setItemName:@&quot;hdhd&quot;]</span><span class="hljs-comment">;</span><br><span class="hljs-section">[item valueInDollars]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>使用dot syntax（点语法）,访问实例对象的存取方法。语法格式：receiver.instance variable。存取方法的用法是相同的，当点语法出现在赋值号左边，表示存方法，出现在赋值号右边表示取方法。点语法是语法糖，编译的时候还是会去调用getter、setter方法</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-type">item</span>.valueInDollars = <span class="hljs-number">5</span>;<br>//equals <span class="hljs-keyword">to</span><br>[<span class="hljs-type">item</span> setValueInDollars:<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><h3 id="self和super关键字"><a href="#self和super关键字" class="headerlink" title="self和super关键字"></a>self和super关键字</h3><ul><li><code>[self method]</code> self存在于方法中，是一个隐式局部变量，程序会自动为self赋值，只想收到消息的对象本身，类似于this。</li><li><code>super method</code>super则是查找父类响应的方法<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3>所有类都是直接或者间接的继承NSObject类，从而都有init方法来初始化对象。可以通过override来重写init方法。任何一个类可以有多个初始化方法，但是必须选择一个作为指定初始化方法（designated initializer）。<br>为什么初始化方法的返回类型是instancetype？这个关键字表示方法的返回类型和调用方法的对象类型相同。之所以返回这种类型是因为，子类就继承init方法，子类执行init方法返回的类型应该是子类类型而不是父类类型（多态性）。<br>id类型，指的是指向任意对象的指针，不仅可以用在返回值类型上也可以用来表示变量和方法参数的类型。注意用id表示指针的时候不需要再加*。<br>在初始化实例变量的时候，一定不要使用存取方法，应该直接访问实例变量。<br>在实现完指定初始化方法之后，其他的初始化方法也要调用指定初始化方法，并传入参数和其他默认值。</li></ul><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>当程序执行某个方法的时候，就会从内存中一个叫栈的空间分配一块内存空间，这个分配的内存叫做帧。帧保存了方法内声明的变量的值（即局部变量），返回地址等，当方法执行完毕之后从栈顶弹出<br>堆Heap：也是内存中的一个区域，和栈是分开的，堆中包含了大量的无序的活动对象，需要通过指针来保存这些对象在堆中的地址。当程序向某个类发送alloc消息的时候，系统就会从堆中分配一块内存存放类声明的实例变量等。堆中的对象不会自动释放，且堆的空间是有限了，因此需要进行内存管理。<br>Apple提供了ARC，即自动引用计数来管理内存，在引入ARC之前都是手动引用计数MRC。</p><h3 id="对象所有权"><a href="#对象所有权" class="headerlink" title="对象所有权"></a>对象所有权</h3><p>指针变量暗含了对其所指的对象的所有权ownership</p><ul><li>当某个方法有一个指向其他对象的局部变量，则称该变量拥有该变量所指的对象</li><li>当某个对象有一个指向其他对象的实例变量，则称该对象拥有该实例变量所指的对象<blockquote><p>如数组存储对象的指针，这些指针暗含了所有权：数组对象拥有了被包含的所有对象。<br>如每个CItem对象拥有实例变量所指的对象。</p></blockquote></li></ul><p>了解对象所有权之后，如果某个对象没有拥有者，就应该将其释放，否则会导致内存泄漏。<br>那么对象在什么情况下会失去拥有者？</p><ol><li>修改指针变量：如_itemName本来指向的对象是@“rusty spork” 后来指向@“shiny sprok” 那么原来的rusty spork就会失去拥有者，因此应该被释放。</li><li>将指针变量的值设为nil：当指针指向nil的时候表示它不再指向其他对象。</li><li>对象的拥有者被释放：对象的拥有者被释放，则会失去一个拥有者。</li><li>从Collection对象中删除对象</li></ol><h3 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h3><ul><li>强引用strong reference：该特性指针变量指向某个对象就会使其多一个拥有者，且不被程序释放。</li><li>弱引用weak reference：该特性指针变量指向某个对象不会使其拥有者个数增加</li></ul><p>弱引用适合解决强引用循环引起的内存泄漏问题，即当两个或者两个以上的对象相互持有强引用特性的指针，会引起强引用循环，对象之间因为相互持有而无法通过ARC机制来释放。<br>在CItem类中，有两个实例变量，_containedItem 、 _container分别表示添加物品和属于其他物品。当实例对象backpack containedItem实例变量指向 实例对象calculator，并且calculator container指向 backpack，这里就存在强引用循环。如果此时将指向两个对象的指针置为nil，则程序无法再使用这两个对象，并且这两个对象会一直占用内存。<br>因此要解决强引用问题，需要先确认对象之间的父子关系，如上面的backpack是父对象，calculator是子对象，父对象的指针为强引用特性，子对象指针为弱引用特性（ _ _ weak修饰变量)</p><h3 id="Autorelease池和ARC"><a href="#Autorelease池和ARC" class="headerlink" title="Autorelease池和ARC"></a>Autorelease池和ARC</h3><ul><li>Autorelease池：当对象收到autorelease消息时，某个自动释放池会成为该对象的临时拥有者。这样就可以解决这类问题：某个方法创建了一个新的对象，但是创建方又不需要成为该对象的拥有者。为了能返回新创建的对象，同时避免提前释放问题，就可以向新创建的对象发送autorelease消息。便捷方法借助自动释放池，将新创建的对象返回给调用方，又不产生内存管理问题。</li><li>如果某个对象不是通过alloc方法或copy方法创建的，就很有可能在返回给调用方前收到过autorelease消息。调用方要根据具体的情况，保留该对象的所有权。否则，在自动释放池被销毁时，程序就会释放这个对象。</li><li>@autoreleasepool指令后面跟一对花括号，可以创建一个自动释放池。在@autoreleasepool的花括号中，如果某个方法返回一个新创建的对象，而该方法的方法名不包含alloc和init，那么这个新创建的对象</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>再引入属性之前，需要为每个类声明一个实例变量并且实现相应地存取方法。引入属性后，通过声明属性就可以完成以上两步，大大减少了代码量且易于理解。</p><h3 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h3><p>语法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (options) 属性类型 属性名称;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>,<span class="hljs-keyword">readwrite</span>) <span class="hljs-built_in">NSString</span> *itemName;<br></code></pre></td></tr></table></figure><p><em>NOTE:编译器会根据属性生成实例变量时会自动在变量名前加上下划线，即属性itemName生成的实例变量为_itemName 取方法itemName和存方法setItemName:</em></p><h3 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h3><ol><li>读写特性 Read&#x2F;write attribute<br>有两种类型可选：readwrite&#x2F;readonly。编译器会根据读写特性生成对应的存取方法，只读特性只生成取方法。</li><li>内存管理特性 Memory management attribute<br>有四种类型可选：strong、waek、copy和unsafe_unretained（非对象属性的默认值）。<ul><li>unsafe_unretained：用于那些不指向任何对象的属性，不需要做内存管理，其存取方法会直接为实例变量赋值。该类型的“不安全”是相对于弱引用而言的。与弱引用不同，unsafe_unretained类型的指针指向的对象被销毁时，指针不会自动设置为nil，而是成为空指针，因此不安全。但是当处理非对象属性（non-object）时，是不会出现空指针问题的。</li><li>对于指向对象的属性，四种类型都有可能，默认是strong类型。当可能存在强引用循环的时候，要将其中的部分属性改成weak，详细看上面。</li><li>当某个属性是指向其他对象的指针，且该对象的类有可修改的子类（NSMutableString、NSMutableArray）时，要将属性设置成copy特性。改成copy之后，存方法会发生一些改变，不是直接将实参赋值给实例变量，而是调用copy方法返回一个新的NSString对象，再赋值给实例变量。这么做是因为，如果属性指向的对象的类有可修改的子类，那么该属性可能会指向可修改的子类对象，同时，该对象可能会被其他拥有者修改。因此，最好先复制该对象，然后再将属性指向复制后的对象。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>)<span class="hljs-built_in">CItem</span> *containedItem;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">weak</span>)<span class="hljs-built_in">CItem</span> *container;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>)<span class="hljs-built_in">NSDate</span> *createDate;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)<span class="hljs-built_in">NSString</span> *itemName;<br><span class="hljs-comment">//_itemName的存方法</span><br>-(<span class="hljs-type">void</span>) setItemName:(<span class="hljs-built_in">NSString</span> *)itemName&#123;<br>    _itemName = [itemName <span class="hljs-keyword">copy</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义属性的存取方法"><a href="#自定义属性的存取方法" class="headerlink" title="自定义属性的存取方法"></a>自定义属性的存取方法</h3>编译器根据属性生成的存取方法都是最简单的存取方法，如果要添加额外的工作，需要覆盖默认方法。当编译器发现有自定义的存方法&#x2F;取方法就不会创建默认的存方法&#x2F;取方法，但仍然会生成没有被覆盖的另一个方法。<br>当存取方法都覆盖，或者只读属性覆盖了取方法，那么编译器不会再生成对应的实例变量，如果需要自己声明。</li></ul></li></ol><h3 id="属性合成"><a href="#属性合成" class="headerlink" title="属性合成"></a>属性合成</h3><p>再头文件中声明属性时，只会生成存取方法的声明，为了让属性生成实例变量和存取方法，属性必须被合成synthesized。默认情况下，编译器会自动合成属性并生成默认的实例变量和存取方法。但如果需要自定义合成方式，要在实现文件中使用@synthesize指令。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 创建存取方法，方法名是age和setAge:，</span><br><br>  　　<span class="hljs-comment">// 同时创建实例变量_age</span><br><br>  　　<span class="hljs-variable">@synthesize</span> age = _age;<br><span class="hljs-comment">//赋值号左边的age表示需要创建存取方法，方法名是age和setAge:。右边的_age表示需要创建实例变量，变量名为_age。</span><br><br><span class="hljs-comment">//也可以不写实例变量的变量名，那么变量名回合方法名相同 </span><br><span class="hljs-comment">//两者等价</span><br><span class="hljs-variable">@synthesize</span> age;<br><span class="hljs-variable">@synthesize</span> age = age;<br></code></pre></td></tr></table></figure><h3 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h3><p>将属性声明在头文件和类扩展中的区别？</p><ul><li>在头文件中声明的属性和方法对其他类是可见的，但有些属性是需要隐藏的</li><li>对于那些只会用在类内部的属性和方法就应该声明在类扩展中。这样就避免了暴露内部实现细节，保证头文件中全是供其他类使用的属性的方法。</li><li>子类无法访问父类在类扩展中声明的属性和方法。</li></ul><h1 id="视图与视图层次结构"><a href="#视图与视图层次结构" class="headerlink" title="视图与视图层次结构"></a>视图与视图层次结构</h1><h2 id="视图层次结构"><a href="#视图层次结构" class="headerlink" title="视图层次结构"></a>视图层次结构</h2><p>一般来说，应用只有一个UIWindow对象，UIWindow作为一个容器，可以包含所有的视图。应用在启动时创建并设置UIWindow对象，并添加其他视图作为子视图，子视图还可以有子视图，因此构成了层次结构。<br><img src="/../img/hierarchy.png" alt="视图层次结构"><br>视图层次结构形成之后，需要将其绘制到屏幕上，绘制的过程可分为两步：</p><ol><li>每个视图分别绘制自己，将自己绘制在图层layer上</li><li>所有的视图的图层组合成一幅图像在绘制到屏幕上。</li></ol><h3 id="frame属性和bounds属性"><a href="#frame属性和bounds属性" class="headerlink" title="frame属性和bounds属性"></a>frame属性和bounds属性</h3><p>在创建UIView的子类之后，通常都会有一个初始化方法<code>initWithFram:(CGRect)frame</code></p><ul><li>视图的frame属性保存的是视图的大小和<strong>相对于父视图的位置</strong>。因为CGRect由CGPoint和CGSize组成。需要注意的是，point的值是相对于父视图的原点坐标。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">frame = CGRectMake(<span class="hljs-number">150</span>,<span class="hljs-number">200</span>,<span class="hljs-number">160</span>,<span class="hljs-number">160</span>);<br><span class="hljs-regexp">//</span>origin(<span class="hljs-number">150</span>,<span class="hljs-number">200</span>) size(<span class="hljs-number">160</span>,<span class="hljs-number">160</span>)<br><span class="hljs-regexp">//</span>origin.x = <span class="hljs-number">150</span> size.height =<span class="hljs-number">160</span>;<br></code></pre></td></tr></table></figure><em>NOTE:这些数值的单位是points不是pixels像素，因为不同屏幕points和分辨率有关。</em></li><li>bounds属性定义了一个矩形范围，表示该视图的绘制区域。</li><li>frame属性和bounds属性的区别：<ul><li>这两个属性所代表的矩形大小是一致的</li><li>frame表示的矩形的位置是相对于父视图的坐标系</li><li>bounds吊饰的矩形位于自己定义的坐标系，可以修改bounds中point来改变其子视图的的位置</li></ul></li></ul><p>改变bounds属性前:<br><img src="../img/beforeChangeBounds.png" width="150" height="250"></p><p>改变bounds属性后:<br><img src="../img/afterChangeBounds.png" width="150" height="250"></p><!-- ![改变bounds属性前](../img/beforeChangeBounds.png)![改变bounds属性后](../img/afterChangeBounds.png) --><p>看图可知，外层的view大小和位置都没有发生改变，而修改了bounds属性后，内层的view的位置发生了偏移，这是因为修改了外层view的坐标系所导致的。<br>如果将父视图的bounds属性赋给子视图的frame属性，子视图将装满父视图</p><h3 id="addSubview方法和superview属性"><a href="#addSubview方法和superview属性" class="headerlink" title="addSubview方法和superview属性"></a>addSubview方法和superview属性</h3><p>每个UIView对象都可以通过addSubview来添加子视图，并且每个UIView对象都有一个superview属性。当一个视图将另一个视图作为子视图加入，会自动创建相应的反向关联，显而易见superview属性是弱引用。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="重写dramRect方法重绘视图"><a href="#重写dramRect方法重绘视图" class="headerlink" title="重写dramRect方法重绘视图"></a>重写dramRect方法重绘视图</h3><p>ios应用启动时会开始一个运行循环（run loop）。运行循环的工作是监听事件，例如触摸。当事件发生时，运行循环会为相应的事件找到合适的处理方法。这些处理方法会调用其他方法，而这些方法又会调用更多其他方法，依此类推。只有当这些方法都执行完毕时，控制权才会再次回到运行循环。<br>　　当应用将控制权交回给运行循环时，运行循环首先会检查是否有等待重绘的视图（即在当前循环收到过setNeedsDisplay消息的视图），然后向所有等待重绘的视图发送drawRect:消息，最后视图层次结构中所有视图的图层再次组合成一幅完整的图像并绘制到屏幕上。<br>iOS做了两方面来优化来保证用户界面的流畅性—-不重绘显示内容没有改变的视图；每次事件处理周期中只发送一次drawrect消息。</p><p>为了标记视图需要重绘，必须向其发送setNeedsDisplay消息，对于SDK提供的视图对象会自动在内容发生改变的时候发送消息，而自定义的UIView子类必须后动发送消息。</p><h3 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h3><h4 id="两个尺寸的区别"><a href="#两个尺寸的区别" class="headerlink" title="两个尺寸的区别"></a>两个尺寸的区别</h4><p>UIScrollView对象适用于那些尺寸大于屏幕的视图。<br>scrollView有两个size，一个是自身的fram的size指的是这个scrollView展示在屏幕上的大小；另一个size是scrollView的contentsize，即它需要呈现的内容的大小。可以把scrollView的大小想象成是镜头的大小，而contentView的大小是需要显示的景观大小。</p><h4 id="拖动和分页"><a href="#拖动和分页" class="headerlink" title="拖动和分页"></a>拖动和分页</h4><p>当contentsize大于scrollview本身的大小时，可以通过拖拽屏幕实现展示不同的内容。<br>scrollview上的子view大小和scrollview对象的大小相同时，如果想实现拖拽时scrollview的边和子view的边对齐显示，那么就需要设置scrollView的pagingEnabled属性为YES，实现分页的效果</p><h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><p>视图控制器是UIViewController类或其子类的对象。每个视图控制器辅助管理一个视图层次结构，包括创建视图层次结构中的视图，处理用户事件，将整个层次结构添加到window中。</p><h3 id="UIViewController的View属性"><a href="#UIViewController的View属性" class="headerlink" title="UIViewController的View属性"></a>UIViewController的View属性</h3><p>view属性指向一个UIview对象，viewcontroller之所以可以管理视图层次结构就是因为view就是层次结构的根视图。当我们将view作为window的子视图时，也会加入viewcontroller对象所管理的层次结构中<br><img src="/../img/controllerHierarchy.png" alt="添加viewController之后的层次结构图"></p><h3 id="controller创建视图层次结构"><a href="#controller创建视图层次结构" class="headerlink" title="controller创建视图层次结构"></a>controller创建视图层次结构</h3><p>视图控制器不会在其被创建出来的那一刻马上创建并载入相应的视图。只有当应用需要将某个视图控制器的视图显示到屏幕上时，相应的视图控制器才会创建其视图。这种延迟加载（lazy loading）视图的做法能提高内存的使用效率。<br>视图控制器可以通过两种方式创建视图层次结构。<br>•代码方式：<strong>覆盖UIViewController中的loadView方法。</strong> 在loadview中将self.view指向要加载的子view</p><p>•文件方式：使用Interface Builder创建一个NIB文件，然后加入所需的视图层次结构，最后视图控制器会在运行时加载由该NIB文件编译而成的XIB文件。</p><p>视图控制器在刚被创建的时候，view属性被初始化为nil，当应用需要将管理器上的视图展示在屏幕上的时候，如果view属性是nil，才会调用loadview方法</p><h3 id="根视图管理器"><a href="#根视图管理器" class="headerlink" title="根视图管理器"></a>根视图管理器</h3><p>我们可以通过视图管理器来创建视图层次机构，如果要将视图管理器的视图层次结构添加到window中，需要调用window的setRootViewController方法。当某个controller成为rootcontroller，window对象会将该controller的view作为子视图加入到窗口。</p><h3 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h3><p>TBC可以保存一组视图控制器，实现在多个controller之间切换。TBC对象在屏幕底部显示一个tabbar，tab bar包括多个tab item，每一个item对应一个TBc对象所保存的视图控制器。通过点击tab item，tbc对象就会展示该标签项所对应的视图控制器的视图。<br>tabbarcontroller是uiviewcontroller的子类，也有一个view的属性，其指向一个包含两个子视图的uiview对象，分别是标签栏和当前选中的视图控制器的视图。<br><img src="/../img/tabbar%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%9B%BE.png"></p><h4 id="设置标签项tab-item"><a href="#设置标签项tab-item" class="headerlink" title="设置标签项tab item"></a>设置标签项tab item</h4><p>标签栏上的每一个item都可以显示标题和图片，通过视图控制器的tabbaritem属性来设置。<br>在item对应的viewcontrol类重写initwithNibNameBundle，设置tabbarItem的title和image。<br>但是在appdelegate.m中却使用init方法来初始化viewcontroller。这是因为initwithNibNameBundle是UIViewController的指定初始化方法，当想视图控制器发送init消息的时候，会调用指定初始化方法，并传入两个nil参数。因此在appdelegate中使用init方法是可以的.</p><h4 id="视图延迟加载"><a href="#视图延迟加载" class="headerlink" title="视图延迟加载"></a>视图延迟加载</h4><p>视图延迟加载机制，会在应用启动之后，默认显示第一个视图控制器的视图，其他的等到需要展示的时候再加载。 视图控制器上的viewDidLoad方法检查视图控制器的视图是否已经加载。如果视图已经加载完之后，在切换标签项也不会再次触发viewdidload方法<br>为了实现视图延迟加载，不应该再initwithnibnamebundle中访问view或者view的子视图，将所有需要对view进行初始化的操作全都放到viewdidload中实现。</p><h4 id="访问视图"><a href="#访问视图" class="headerlink" title="访问视图"></a>访问视图</h4><p>通常需要在用户看到XIB文件中创建视图之前，对其进行初始化操作，但是根据延迟加载机制，不可能在视图控制器初始化方法中初始化视图，那么如何初始化？<br>主要有两种方法：viewDidLoad viewWillAppear</p><ol><li>viewDidLoad方法：应用启动后只调用一次</li><li>viewWillAppear方法：每次需要展示视图控制器的view的时候都会调用</li></ol><p>需求：在reminderViewController中有一个子视图dataPicker，现在是允许用户选择任意时间，如果需要设置用户只能选择当前时间之后的时间。<br>那么datapicker子视图每次展示的时候都是不一样的，需要不停的初始化，那么就需要在viewwillappear中初始化。</p><h2 id="UITableView和UITableViewController"><a href="#UITableView和UITableViewController" class="headerlink" title="UITableView和UITableViewController"></a>UITableView和UITableViewController</h2><p>iOS应用需要在界面上呈现某种列表控件，用户可以选中、删除或重排等，这些可以由UITableView完成。UITableView虽然只显示一列数据，但是没有行的限制。</p><p>根据MVC设计模式，UITableView不负责处理应用的逻辑和数据，所以需要一个和UITableView一起工作的对象：</p><ul><li>通常情况下，要通过某个视图控制对象来创建和释放UITableView对象，并负责显示或隐藏视图。</li><li>UITableView对象要有数据源才能正常工作。UITableView对象会向数据源查询要显示的行数、显示表格行所需的数据和其他所需的数据。没有数据源的UITableView对象只是空壳。凡是遵守UITableViewDataSource协议的Objective-C对象，都可以成为UITableView对象的数据源（即dataSource属性所指向的对象）。</li><li>通常情况下，要为UITableView对象设置委托对象，以便能在该对象发生特定事件时做出相应的处理。凡是遵守UITableViewDelegate协议的对象，都可以成为UITableView对象的委托对象。<br>UITableViewController可以满足以上要求：控制视图对象，数据源、委托对象。<br>UITableViewController作为UIViewController的子类也拥有view属性，其view属性指向一个UITableView对象，并且该对象由UITableViewController对象负责设置和显示。UITableViewController在创建UITableView对象之后，会将UITableView对象的delegate和datasource指向自己<br><img src="/../img/UITableViewController%E5%AF%B9%E8%B1%A1%E5%9B%BE.png"></li></ul><p>现在将UITableViewController的指定初始化方法改为init:，为此需要遵守以下两条规则：<br>　　•在新的指定初始化方法中调用父类的指定初始化方法。<br>　　•覆盖父类的指定初始化方法，调用新的指定初始化方法。</p><h1 id="触摸事件与UIResponder"><a href="#触摸事件与UIResponder" class="headerlink" title="触摸事件与UIResponder"></a>触摸事件与UIResponder</h1><h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><p>UIView是UIResponder的子类，可以处理四种不同的触摸事件</p><ul><li>touchesBegan：withEvent 手指触摸屏幕</li><li>touchesMoved：WithEvent 手指在屏幕上移动</li><li>touchesEnded：withEvent 手指离开屏幕</li><li>touchesCancelled：withEvent 在触摸操作结束前，被系统事件打断</li></ul><p>当系统检测到手指触摸屏幕的事件后，就会创建UITouch对象（一根手指的触摸事件对应一个UITouch对象）。发生触摸事件的UIView对象会收到touchesBegan:withEvent:消息，系统传入的第一个实参touches（NSSet对象）会包含所有相关的UITouch对象。<br>　　当手指在屏幕上移动时，系统会更新相应的UITouch对象，为其重新设置对应的手指在屏幕上的位置。最初发生触摸事件的那个UIView对象会收到touchesMoved:withEvent:消息，系统传入的第一个实参touches（NSSet对象）会包含所有相关的UITouch对象，而且这些UITouch对象都是最初发生触摸事件时创建的。</p><p>　　当手指离开屏幕时，系统会最后一次更新相应的UITouch对象，为其重新设置对应的手指在屏幕上的位置。接着，最初发生该触摸事件的视图会收到touchesEnded:withEvent:消息。当收到该消息的视图执行完touchesEnded:withEvent:后，系统就会释放和当前事件有关的UITouch对象<br>总结</p><ul><li>一个UITouch对象对应屏幕上的一个手指，只要手指没离开屏幕UItouch对象就不会销毁，uitouch对象会保存手指在屏幕上的位置。</li><li>当初发生触摸事件的视图会在各个阶段收到相应的触摸事件消息，即使手指已经离开了这个视图的frame区域，系统也会给这个视图发送touchesmove&#x2F;touchesended消息，即当视图发生触摸，之后的所有触摸事件都属于它</li></ul><p>当应用发生某个触摸事件后（例如触摸开始、手指移动、触摸结束），系统都会将该事件添加至一个由UIApplication单例管理的事件队列。通常情况下，很少会出现满队列的情况，所以UIApplication会立刻分发队列中的事件。分发某个触摸事件时，UIApplication会向“拥有”该事件的视图发送特定的UIResponder消息（如果读者在执行触摸操作时感觉应用的反应迟缓，就很有可能是因为应用的某个方法占用了大量CPU时间，导致队列堵塞。第14章会介绍如何查出产生这类问题的原因）。<br>　　当多根手指在同一个视图、同一个时刻执行相同的触摸动作时，UIApplication会用单个消息、一次分发所有相关的UITouch对象。UIApplication在发送特定的UIResponder消息时，会传入一个NSSet对象，该对象将包含所有相关的UITouch对象（一个UITouch对象对应一根手指）。但是，因为UIApplication对“同一个时刻”的判断很严格，所以通常情况下，哪怕一组事件都是在很短的一段时间内发生的，UIApplication也会发送多个UIResponder消息，分批发送UITouch对象。</p><h2 id="UIGestureRecognizer"><a href="#UIGestureRecognizer" class="headerlink" title="UIGestureRecognizer"></a>UIGestureRecognizer</h2><p>在为应用添加手势识别功能时，需要针对特定的手指创建相应的UIGestureRecognizer子类对象</p><h1 id="委托和文本输入"><a href="#委托和文本输入" class="headerlink" title="委托和文本输入"></a>委托和文本输入</h1><h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p>UIResponder是UIKit框架的一个抽象类，包括很多子类：</p><ul><li>UIView</li><li>UIViewController</li><li>UIApplication</li></ul><p>UIResponder定义了一系列方法用于接收和处理用户事件，如触摸、运动事件（晃动）、功能控制（编辑文本、播放音乐）等。<br>系统会讲触摸事件发送到被触摸的视图，其他类型的事件会由第一响应者负责处理。UIWindow有一个fisrtResponder属性指向第一响应者。当用户点击textfield，该对象会成为第一响应者，firstResponder指针会指向该对象，之后应用接收到运动事件或者功能控制事件会就发送给第一响应者。<br><img src="/../img/firstResponder.png"></p><p>当某个UITextField对象或UITextView对象成为第一响应者时，屏幕会弹出键盘。除了用户点击之外，还可以在代码中向UITextField对象发送becomeFirstResponder消息，使其成为第一响应者。相反，如果要关闭键盘，则可以向UITextField对象发送resignFirstResponder消息，且要求该对象放弃第一响应者状态。一旦第一响应者不是UITextField对象，键盘就会消失。<br>大部分的视图并不需要称为第一响应者，如UISlider对象，该对象只需要处理触摸事件，不会接受其他类型的事件，因此不用称为第一响应者。</p><h2 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h2><p>UILabel用来显示文本，UITextField可以接受用户的输入。</p><h3 id="设置textField的键盘"><a href="#设置textField的键盘" class="headerlink" title="设置textField的键盘"></a>设置textField的键盘</h3><p>UITextField对象有一系列属性用来设置弹出的键盘。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">textFiled.placeholder</span> = @<span class="hljs-string">&quot;Hypnotize me.&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attr">textFiled.returnKeyType</span> = UIReturnKeyDone<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>设置编辑栏的占位符文本和键盘的换行符的文本</p><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>在之前使用过Target-Action设计模式，是UIKit中常用的设计模式。该设计模式的工作方式：当某个特定事件发生时（如按下按钮），发生事件的一方会向特定的目标对象发送一个预设好的动作消息。但是这种设计模式的缺陷在于，时间和目标时一对一的。比如说按下按钮，目标就是处理点击事件。如果是比较复杂的事件就不能用这种模式处理。<br>UITextField对象具有一个委托属性delegate，这个委托是UITextFieldDelegate类型的。以下是委托方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">UITextFieldDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br><span class="hljs-keyword">@optional</span><br><br>- (<span class="hljs-type">BOOL</span>)textFieldShouldBeginEditing:(<span class="hljs-built_in">UITextField</span> *)textField;        <span class="hljs-comment">// return NO to disallow editing.</span><br>- (<span class="hljs-type">void</span>)textFieldDidBeginEditing:(<span class="hljs-built_in">UITextField</span> *)textField;           <span class="hljs-comment">// became first responder</span><br>- (<span class="hljs-type">BOOL</span>)textFieldShouldEndEditing:(<span class="hljs-built_in">UITextField</span> *)textField;          <span class="hljs-comment">// return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end</span><br>- (<span class="hljs-type">void</span>)textFieldDidEndEditing:(<span class="hljs-built_in">UITextField</span> *)textField;             <span class="hljs-comment">// may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called</span><br>- (<span class="hljs-type">void</span>)textFieldDidEndEditing:(<span class="hljs-built_in">UITextField</span> *)textField reason:(<span class="hljs-built_in">UITextFieldDidEndEditingReason</span>)reason API_AVAILABLE(ios(<span class="hljs-number">10.0</span>)); <span class="hljs-comment">// if implemented, called in place of textFieldDidEndEditing:</span><br><br>- (<span class="hljs-type">BOOL</span>)textField:(<span class="hljs-built_in">UITextField</span> *)textField shouldChangeCharactersInRange:(<span class="hljs-built_in">NSRange</span>)range replacementString:(<span class="hljs-built_in">NSString</span> *)string;   <span class="hljs-comment">// return NO to not change text</span><br><br>- (<span class="hljs-type">void</span>)textFieldDidChangeSelection:(<span class="hljs-built_in">UITextField</span> *)textField API_AVAILABLE(ios(<span class="hljs-number">13.0</span>), tvos(<span class="hljs-number">13.0</span>));<br><br>- (<span class="hljs-type">BOOL</span>)textFieldShouldClear:(<span class="hljs-built_in">UITextField</span> *)textField;               <span class="hljs-comment">// called when clear button pressed. return NO to ignore (no notifications)</span><br>- (<span class="hljs-type">BOOL</span>)textFieldShouldReturn:(<span class="hljs-built_in">UITextField</span> *)textField;              <span class="hljs-comment">// called when &#x27;return&#x27; key pressed. return NO to ignore.</span><br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p><em>NOTE：在委托方法中通常将对象自身作为第一个参数，如果视图控制器有多个TextField对象，她们的委托都是该视图控制器，那么就需要根据textFielf参数获得相应的textField对象并执行不同的操作。</em></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><blockquote><p>被委托对象：拥有一个delegate属性，以及有协议，协议中声明了一些方法<br>委托对象：委托对象需要根据协议实现相应的方法。并在头文件或者类扩展@interface指令后面 将遵守的协议写在尖括号里。<br>textField.delegate &#x3D; self;<br>textField对象就是被委托对象，self，即这里的视图控制器就是委托对象<br>textFielf对象委托视图控制器来完成一些callback<br>支持委托的对象，都有一个协议，声明了可以向该对象的委托对象发送的消息，委托对象需要根据需求实现相应的方法。<br>声明协议的语法是，使用@protocol指令 后面跟着协议名称 <NSObject><br>尖括号内包括了NSObject协议的全部方法。如何声明协议的新增方法，@end结束<br><em>NOTE：协议不是类，只是一组方法声明，协议本身不实现方法，只有委托对象才会实现协议里的方法，相当于市java中的接口的概念</em><br>协议中声明的方法可分为必须实现的@required和可选的@optional<br>被委托对象在调用可选方法之前，会像委托对象发送一个<code>respondsToSelector:</code>消息，判断委托对象是否实现了指定的方法。<br>需要注意的是，几乎所有的委托都是弱引用属性，这是为了避免对象和委托对象之间产生强引用循环。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">weak</span>)   <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">UITextFieldDelegate</span>&gt; delegate;             <span class="hljs-comment">// default is nil. weak reference</span><br><br></code></pre></td></tr></table></figure><p><img src="/../img/weakDelegate.png"></p><h2 id="运动效果"><a href="#运动效果" class="headerlink" title="运动效果"></a>运动效果</h2><blockquote><p>ios设备内嵌了许多功能强大的传感器，例如加速传感器，磁场传感器和三轴陀螺仪等。应用可以通过这些感应器了解设备的速度、方向和角度，并实现有用的功能。例如，应用可以根据设备的方向自动将界面调整为横排模式或竖排模式。<br>应用可以通过UIInterpolatingMotionEffect类实现效果，设置方向，键路径，相对值，在添加到视图上。</p></blockquote><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h1 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h1><h2 id="键值编码"><a href="#键值编码" class="headerlink" title="键值编码"></a>键值编码</h2><p>当NIB文件被加载之后，outlet便利是通过KVC的方式来设置的。键值编码valueForKey： 和 setValue：forKey方法来实现通过属性的名称来存取属性的值。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">id currentFido = [selectedObject valueForKey:@<span class="hljs-string">&quot;fido&quot;</span>];<br>[selectedObject setValue:value forKey:@<span class="hljs-string">&quot;fido&quot;</span>];<br></code></pre></td></tr></table></figure><p>NIB文件在加载时会使用setValue:forKey:设置插座变量。例如，如果需要为某个对象设置一个名为rex的插座变量，那么该对象必须定义了setRex:方法或者具有_rex实例变量（或rex实例变量），否则在加载NIB文件时会抛出异常</p><h2 id="Retina显示屏"><a href="#Retina显示屏" class="headerlink" title="Retina显示屏"></a>Retina显示屏</h2><h2 id="main和UIApplication"><a href="#main和UIApplication" class="headerlink" title="main和UIApplication"></a>main和UIApplication</h2><p>在OC的main函数里的UIApplicationMain函数会创建一个UIApplication对象。每一个iOS应用只有一个UIApplication对象，该对象的作用是维护运行循环。一旦程序创建了该对象之后，运行循环就会一直循环下去，main（）的执行也会因此阻塞。<br>此外，UIApplicationMain函数还会创建某个指定类的对象，并将其设置为UIApplication对象的delegate。该对象的类是由UIApplicationMain函数的最后一个实参指定的，该实参的类型是NSString对象，代表的是某个类的类名。所以在以上这段代码中，UIApplicationMain会创建一个BNRAppDelegate对象，并将其设置为UIApplication对象的delegate。<br>在应用启动运行循环并开始接收事件前，UIApplication对象会向其委托发送一个特定的消息，使应用能有机会完成相应的初始化工作。这个消息的名称是application:didFinishLaunchingWithOptions:</p><h2 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h2><p>许多继承UIResponder的子类既不是视图对象，也无法触摸显示，这些子类无法直接发送触摸事件，但是可以响应对象链接接受事件。<br>UIResponder对象拥有一个名为nextResponder的指针，相关的UIResponder对象可以通过该指针组成一个响应对象链。当UIView对象属于某个UIViewController对象时，其nextResponder指针就会指向包含该视图的UIViewController对象。当UIView对象不属于任何UIViewController对象时，其nextResponder指针就会指向该视图的父视图。UIViewController对象的nextResponder通常会指向其视图的父视图。最顶层的父视图是UIWindow对象，而UIWindow对象的nextResponder指向的是UIApplication单例。<br><img src="/../img/%E5%93%8D%E5%BA%94%E9%93%BE.png"><br>如果UIResponder没有处理传给它的事件，该对象会讲未处理的次奥西转发给自己的nextResponder。这就是touchedbegin方法默认的实现方式。只要没有为某个UIresponder对象覆盖该方法，那么该对象nextRedponder会尝试处理，最终传递给UIapplication，如果其也无法处理就会丢弃。</p><h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p>UIControl是UIButton UISlider的父类，一般对于UIcontrol对象设置action-target方法来处理逻辑。<br>对于UIControl对象，每个可能触发的控件事件都有一个对应的常量。以UIButton对象为例，该对象的常用控件事件是UIControlEventTouchUpInside。如果某个目标对象是针对UIControlEventTouchUpInside注册的，那么只有当用户触摸了这个UIControl对象，并且手指是在该对象的frame区域内离开屏幕时，目标对象才会收到指定的动作消息。因此，可以将控件事件UIControlEventTouchUpInside视为按下操作。<br>为实现，无论用户手指是在frame内还是外离开屏幕都会触发某个事件的逻辑</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[button addTraget:<span class="hljs-keyword">self</span><br>           action:<span class="hljs-keyword">@selector</span>(xxx)<br> forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span><br>      | <span class="hljs-built_in">UIControlEventTouchUpOutside</span> ];<br></code></pre></td></tr></table></figure><p>那么UIControl对象是如何将这些动作消息发送给相应的目标对象的？在上面这段touchesEnded:withEvent:方法的末尾，UIControl对象会向自己发送sendActions- ForControlEvents:消息。该消息会遍历UIControl对象的所有目标-动作对，根据传入的控件事件类型进行查找，然后向匹配的目标对象发送对应的动作消息。<br>　　但是，UIControl对象绝对不是直接向目标对象发送消息，而是要通过UIApplication转发。为什么UIControl对象不能直接向目标对象发送动作消息？这是因为在UIControl对象所拥有的目标-动作对中，目标对象可以是nil。UIApplication在转发源自UIControl对象的消息时，会先判断目标对象是不是nil。如果是nil，UIApplication就会先找出UIWindow对象的第一响应对象，然后向第一响应对象发送相应的动作消息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS 语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS网络</title>
    <link href="/2022/05/05/iOS%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/05/05/iOS%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/05/hello-world/"/>
    <url>/2022/05/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
