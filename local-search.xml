<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS编程</title>
    <link href="/2022/05/06/iOS%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/06/iOS%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Objective-C-基础语法"><a href="#Objective-C-基础语法" class="headerlink" title="Objective-C 基础语法"></a>Objective-C 基础语法</h1><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><blockquote><p>当某个对象初始化完成了，就可以向其发送消息，消息需要包括三个部分</p><ul><li>receiver接收方：是一个指针，指向执行方法的对象</li><li>selector选择器：需要执行方法的方法名</li><li>arguments实参：以变量形式传递给方法的数值</li></ul></blockquote><p><code>[person sayHi:someName];</code> 向Person类的实例对象person发送sayHi消息，该消息会触发person的sayHi方法，并传入参数someName<br><code>[person sayHi:someName       withGift:someGift];</code>  这条消息接受多个实参，每个实参都会和选择其中的对应的标签配对，每个标签以冒号结束。</p><p><strong>NOTE：所有的标签合在一起才构成一个selector，并且即使有多个标签，但是仍然只触发了一个方法，即sayHi：withGift：方法</strong></p><p>在OC中，方法的唯一性只取决于方法名，即使参数类型返回值类型不同，一个类也不允许出现两个名称相同的方法。<br><em>NOTE：在OC中，需要注意方法和消息的区别，方法指的是一块可执行的代码，消息指的是要求类或者实例对象执行某个方法的动作。</em></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在OC中数组包含的对象不是对象本身，而是指向对象的指针，即数组保存对象的内存地址。<br>NSMutableArray是NSArray的子类，可以动态的添加删除元素。<br>使用<code>addObject:</code> 尾插法添加元素 <code>insertObject:atIndex:</code> 在执行位置加入元素<br><code>objectAtIndex: </code>访问执行位置的元素    <code>count</code> 返回数组元素的个数<br>快速枚举（fast enumeration）</p><figure class="highlight scss"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(NSString *item in array)&#123;<br>    <span class="hljs-built_in">NSL</span>(xxx);<br>&#125;   <br></code></pre></td></tr></table></figure><p><strong>NOTE：需要注意的是，使用fast enumreation的时候，不能在循环体内添加或者删除元素，会报并发修改异常</strong></p><h4 id="深入学习数组"><a href="#深入学习数组" class="headerlink" title="深入学习数组"></a>深入学习数组</h4><p>OC中数组可以存储不同类型的对象，因为存的是对象的指针（指针大小一致），不像其他强类型语言只能保存一种类型的对象。并且因为数组存的是对象的指针，因此基本类型不能存，需要包装成<code>NSNumber</code>、<code>NSValue</code>、<code>NSData</code>等<br>需要注意数组不能存nil，需要将nil转成NSNull对象<br>访问数组对象的时候，可以使用下标语法<br><code> [items objectAtIndex:3] == items[3]</code> </p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CItem</span> : <span class="hljs-title">NSObject</span></span><br>&#123;<br>    <span class="hljs-built_in">NSString</span> *_itemNAme;<br>    <span class="hljs-built_in">NSString</span> *_serialNumber;<br>    <span class="hljs-type">int</span> _valueInDollars;<br>    <span class="hljs-built_in">NSDate</span> *_dateCreated;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对CItem类来说，每个实例对象包含了一个int类型的数值，和是哪个指向对象的指针。如_itemName指向一个NSString对象，该对象的内容是“RED SOFA”字符串，需要注意的是，_itemName存的是该字符串的地址，而不是字符串本身.</p><h3 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h3><p>在OC中，存方法的命名规则：set+要修改的实例变量的变量名，如setItemName；取方法的命名规则：实例变量的变量名，如itemName。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[item setItemName:@&quot;hdhd&quot;]</span><span class="hljs-comment">;</span><br><span class="hljs-section">[item valueInDollars]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>使用dot syntax（点语法）,访问实例对象的存取方法。语法格式：receiver.instance variable。存取方法的用法是相同的，当点语法出现在赋值号左边，表示存方法，出现在赋值号右边表示取方法。点语法是语法糖，编译的时候还是会去调用getter、setter方法</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-type">item</span>.valueInDollars = <span class="hljs-number">5</span>;<br>//equals <span class="hljs-keyword">to</span><br>[<span class="hljs-type">item</span> setValueInDollars:<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><h3 id="self和super关键字"><a href="#self和super关键字" class="headerlink" title="self和super关键字"></a>self和super关键字</h3><ul><li><code>[self method]</code> self存在于方法中，是一个隐式局部变量，程序会自动为self赋值，只想收到消息的对象本身，类似于this。</li><li><code>super method</code>super则是查找父类响应的方法<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3>所有类都是直接或者间接的继承NSObject类，从而都有init方法来初始化对象。可以通过override来重写init方法。任何一个类可以有多个初始化方法，但是必须选择一个作为指定初始化方法（designated initializer）。<br>为什么初始化方法的返回类型是instancetype？这个关键字表示方法的返回类型和调用方法的对象类型相同。之所以返回这种类型是因为，子类就继承init方法，子类执行init方法返回的类型应该是子类类型而不是父类类型（多态性）。<br>id类型，指的是指向任意对象的指针，不仅可以用在返回值类型上也可以用来表示变量和方法参数的类型。注意用id表示指针的时候不需要再加*。<br>在初始化实例变量的时候，一定不要使用存取方法，应该直接访问实例变量。<br>在实现完指定初始化方法之后，其他的初始化方法也要调用指定初始化方法，并传入参数和其他默认值。</li></ul><h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>当程序执行某个方法的时候，就会从内存中一个叫栈的空间分配一块内存空间，这个分配的内存叫做帧。帧保存了方法内声明的变量的值（即局部变量），返回地址等，当方法执行完毕之后从栈顶弹出<br>堆Heap：也是内存中的一个区域，和栈是分开的，堆中包含了大量的无序的活动对象，需要通过指针来保存这些对象在堆中的地址。当程序向某个类发送alloc消息的时候，系统就会从堆中分配一块内存存放类声明的实例变量等。堆中的对象不会自动释放，且堆的空间是有限了，因此需要进行内存管理。Apple提供了ARC，即自动引用计数来管理内存，在引入ARC之前都是手动引用计数MRC。</p><h3 id="对象所有权"><a href="#对象所有权" class="headerlink" title="对象所有权"></a>对象所有权</h3><p>指针变量暗含了对其所指的对象的所有权ownership</p><ul><li>当某个方法有一个指向其他对象的局部变量，则称该变量拥有该变量所指的对象</li><li>当某个对象有一个指向其他对象的实例变量，则称该对象拥有该实例变量所指的对象<blockquote><p>如数组存储对象的指针，这些指针暗含了所有权：数组对象拥有了被包含的所有对象。<br>如每个CItem对象拥有实例变量所指的对象。</p></blockquote></li></ul><p>了解对象所有权之后，如果某个对象没有拥有者，就应该将其释放，否则会导致内存泄漏。<br>那么对象在什么情况下会失去拥有者？</p><ol><li>修改指针变量：如_itemName本来指向的对象是@“rusty spork” 后来指向@“shiny sprok” 那么原来的rusty spork就会失去拥有者，因此应该被释放。</li><li>将指针变量的值设为nil：当指针指向nil的时候表示它不再指向其他对象。</li><li>对象的拥有者被释放：对象的拥有者被释放，则会失去一个拥有者。</li><li>从Collection对象中删除对象</li></ol><h3 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h3><ul><li>强引用strong reference：该特性指针变量指向某个对象就会使其多一个拥有者，且不被程序释放。</li><li>弱引用weak reference：该特性指针变量指向某个对象不会使其拥有者个数增加</li></ul><p>弱引用适合解决强引用循环引起的内存泄漏问题，即当两个或者两个以上的对象相互持有强引用特性的指针，会引起强引用循环，对象之间因为相互持有而无法通过ARC机制来释放。<br>在CItem类中，有两个实例变量，_containedItem 、 _container分别表示添加物品和属于其他物品。当实例对象backpack containedItem实例变量指向 实例对象calculator，并且calculator container指向 backpack，这里就存在强引用循环。如果此时将指向两个对象的指针置为nil，则程序无法再使用这两个对象，并且这两个对象会一直占用内存。<br>因此要解决强引用问题，需要先确认对象之间的父子关系，如上面的backpack是父对象，calculator是子对象，父对象的指针为强引用特性，子对象指针为弱引用特性（ _ _ weak修饰变量)</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>再引入属性之前，需要为每个类声明一个实例变量并且实现相应地存取方法。引入属性后，通过声明属性就可以完成以上两步，大大减少了代码量且易于理解。</p><h3 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h3><p>语法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (options) 属性类型 属性名称;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>,<span class="hljs-keyword">readwrite</span>) <span class="hljs-built_in">NSString</span> *itemName;<br></code></pre></td></tr></table></figure><p><em>NOTE:编译器会根据属性生成实例变量时会自动在变量名前加上下划线，即属性itemName生成的实例变量为_itemName 取方法itemName和存方法setItemName:</em></p><h3 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h3><ol><li>读写特性 Read&#x2F;write attribute<br>有两种类型可选：readwrite&#x2F;readonly。编译器会根据读写特性生成对应的存取方法，只读特性只生成取方法。</li><li>内存管理特性 Memory management attribute<br>有四种类型可选：strong、waek、copy和unsafe_unretained（非对象属性的默认值）。<ul><li>unsafe_unretained：用于那些不指向任何对象的属性，不需要做内存管理，其存取方法会直接为实例变量赋值。该类型的“不安全”是相对于弱引用而言的。与弱引用不同，unsafe_unretained类型的指针指向的对象被销毁时，指针不会自动设置为nil，而是成为空指针，因此不安全。但是当处理非对象属性（non-object）时，是不会出现空指针问题的。</li><li>对于指向对象的属性，四种类型都有可能，默认是strong类型。当可能存在强引用循环的时候，要将其中的部分属性改成weak，详细看上面。</li><li>当某个属性是指向其他对象的指针，且该对象的类有可修改的子类（NSMutableString、NSMutableArray）时，要将属性设置成copy特性。改成copy之后，存方法会发生一些改变，不是直接将实参赋值给实例变量，而是调用copy方法返回一个新的NSString对象，再赋值给实例变量。这么做是因为，如果属性指向的对象的类有可修改的子类，那么该属性可能会指向可修改的子类对象，同时，该对象可能会被其他拥有者修改。因此，最好先复制该对象，然后再将属性指向复制后的对象。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>)<span class="hljs-built_in">CItem</span> *containedItem;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">weak</span>)<span class="hljs-built_in">CItem</span> *container;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>)<span class="hljs-built_in">NSDate</span> *createDate;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)<span class="hljs-built_in">NSString</span> *itemName;<br><span class="hljs-comment">//_itemName的存方法</span><br>-(<span class="hljs-type">void</span>) setItemName:(<span class="hljs-built_in">NSString</span> *)itemName&#123;<br>    _itemName = [itemName <span class="hljs-keyword">copy</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义属性的存取方法"><a href="#自定义属性的存取方法" class="headerlink" title="自定义属性的存取方法"></a>自定义属性的存取方法</h3>编译器根据属性生成的存取方法都是最简单的存取方法，如果要添加额外的工作，需要覆盖默认方法。当编译器发现有自定义的存方法&#x2F;取方法就不会创建默认的存方法&#x2F;取方法，但仍然会生成没有被覆盖的另一个方法。<br>当存取方法都覆盖，或者只读属性覆盖了取方法，那么编译器不会再生成对应的实例变量，如果需要自己声明。</li></ul></li></ol><h3 id="属性合成"><a href="#属性合成" class="headerlink" title="属性合成"></a>属性合成</h3><p>再头文件中声明属性时，只会生成存取方法的声明，为了让属性生成实例变量和存取方法，属性必须被合成synthesized。默认情况下，编译器会自动合成属性并生成默认的实例变量和存取方法。但如果需要自定义合成方式，要在实现文件中使用@synthesize指令。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 创建存取方法，方法名是age和setAge:，</span><br><br>  　　<span class="hljs-comment">// 同时创建实例变量_age</span><br><br>  　　<span class="hljs-variable">@synthesize</span> age = _age;<br><span class="hljs-comment">//赋值号左边的age表示需要创建存取方法，方法名是age和setAge:。右边的_age表示需要创建实例变量，变量名为_age。</span><br><br><span class="hljs-comment">//也可以不写实例变量的变量名，那么变量名回合方法名相同 </span><br><span class="hljs-comment">//两者等价</span><br><span class="hljs-variable">@synthesize</span> age;<br><span class="hljs-variable">@synthesize</span> age = age;<br></code></pre></td></tr></table></figure><h3 id="Autorelease池和ARC"><a href="#Autorelease池和ARC" class="headerlink" title="Autorelease池和ARC"></a>Autorelease池和ARC</h3><ul><li>Autorelease池：当对象收到autorelease消息时，某个自动释放池会成为该对象的临时拥有者。这样就可以解决这类问题：某个方法创建了一个新的对象，但是创建方又不需要成为该对象的拥有者。为了能返回新创建的对象，同时避免提前释放问题，就可以向新创建的对象发送autorelease消息。便捷方法借助自动释放池，将新创建的对象返回给调用方，又不产生内存管理问题。</li><li>如果某个对象不是通过alloc方法或copy方法创建的，就很有可能在返回给调用方前收到过autorelease消息。调用方要根据具体的情况，保留该对象的所有权。否则，在自动释放池被销毁时，程序就会释放这个对象。</li><li>@autoreleasepool指令后面跟一对花括号，可以创建一个自动释放池。在@autoreleasepool的花括号中，如果某个方法返回一个新创建的对象，而该方法的方法名不包含alloc和init，那么这个新创建的对象通常会被放入相应的自动释放池。在应用执行完某个@autoreleasepool中的程序段后，该自动释放池中的所有对象都会失去一个拥有者</li></ul><h1 id="视图和视图层级结构"><a href="#视图和视图层级结构" class="headerlink" title="视图和视图层级结构"></a>视图和视图层级结构</h1>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2022/05/05/test/"/>
    <url>/2022/05/05/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/05/hello-world/"/>
    <url>/2022/05/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
